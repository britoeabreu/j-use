
model BPMN2

--- Processing Enumerations 

 enum AdHocOrdering {
		Parallel,
		Sequential
 } --AdHocOrdering

 enum MultiInstanceBehavior {
		None,
		One,
		All,
		Complex
 } --MultiInstanceBehavior

 enum AssociationDirection {
		None,
		One,
		Both
 } --AssociationDirection

 enum MessageVisibleKind {
		Initiating,
		NonInitiating
 } --MessageVisibleKind

 enum ParticipantBandKind {
		TopInitiating,
		TopNonInitiating,
		BottomInitiating,
		BottomNonInitiating,
		MiddleInitiating,
		MiddleNonInitiating
 } --ParticipantBandKind

 enum ChoreographyLoopType {
		None,
		Standard,
		MultiInstanceSequential,
		MultiInstanceParallel
 } --ChoreographyLoopType

 enum ItemKind {
		Physical,
		Information
 } --ItemKind

 enum RelationshipDirection {
		None,
		Forward,
		Backward,
		Both
 } --RelationshipDirection

 enum EventBasedGatewayType {
		Parallel,
		Exclusive
 } --EventBasedGatewayType

 enum GatewayDirection {
		Unspecified,
		Converging,
		Diverging,
		Mixed
 } --GatewayDirection

 enum ProcessType {
		None,
		Public,
		Private
 } --ProcessType

--- Processing Abstract Classes 

 abstract class InteractionNode
	operations
	-- Returns the outgoing MessageFlows from the current InteractionNode
	outputMessageFlows(): Set(MessageFlow) = self.messageFlow

	-- Returns the number of outgoing MessageFlows from the current InteractionNode
		numberOutputMessageFlows(): Integer = self.outputMessageFlows()->size() 

	-- Returns true if the current InteractionNode has outgoing MessageFlows
	hasOutputMessageFlows(): Boolean = self.outputMessageFlows()->notEmpty()

	-- Returns the incoming MessageFlows to the current InteractionNode
	inputMessageFlows(): Set(MessageFlow) = self.messageFlow_a

	-- Returns the number of incoming MessageFlows to the current InteractionNode
		numberInputMessageFlows(): Integer = self.inputMessageFlows()->size()

	-- Returns true if the current InteractionNode has incoming MessageFlows
	hasInputMessageFlows(): Boolean = self.inputMessageFlows()->notEmpty()

	-- Returns the outgoing + incoming MessageFlows to the current InteractionNode
	messageFlows(): Set(MessageFlow) = outputMessageFlows()->union(inputMessageFlows())->asSet()

	-- Returns the number of connecting (incoming+outgoing) MessageFlows to/from the current interactionNode
	numberMessageFlows(): Integer = self.inputMessageFlows()->size() + self.outputMessageFlows()->size()

	 	-- abstract implementation to implement in concrete classes
		successors1(): Set(OclAny) = successors1_InteractionNode()

 	-- Returns the messageFlows sucessors of an InteractionNode 
	successors1_InteractionNode(): Set(OclAny) = self.messageFlow

	-- abstract implementation to implement in inherited classes of InteractionNode 
	successors(): Set(OclAny) = self.successors_InteractionNode()

	-- Returns the interactionNodes successors of the current interactionNode 
	successors_InteractionNode(): Set(OclAny) = self.messageFlow.targetRef->asSet()

	-- Returns only the interactionNode successors of the current InteractionNode 
	successors2(): Set(OclAny) = self.messageFlow.targetRef->asSet()

		-- return the pool where a interactionNode is located
		messagePool(element : InteractionNode)  : Set(Participant) =
				if element.isDefined() and element.oclIsTypeOf(Task) then
						element.oclAsType(Task).searchPool(element.oclAsType(Task),
																	element.oclAsType(Task).container)
				else
					if element.isDefined() and element.oclIsKindOf(Event)  then
							element.oclAsType(Event).searchPool(element.oclAsType(Event) , 
											element.oclAsType(Event).container)
					else
							oclEmpty(Set(Participant))
					endif
				endif

 end --InteractionNode

 abstract class BaseElement
	attributes
		id : String
operations
	-- função que calcula a potência
	power(x: Real, n: Integer): Real =
		if  (n=1) then
			x 
		else
			x * power(x, n-1)
		endif

	-- função que calcula o logaritmo 
	logarithm(base: Real, x: Real): Real = ln(x) / ln(base)

	ln(z: Real): Real = 2 * ln_aux(z, 0, 0, 0.0001)

		-- pre: z >=0 
	ln_aux(z: Real, n: Integer, previous: Real, delta: Real): Real =
		if (ln_sum(n+1, z) < delta) then
			previous
		else 
			ln_aux(z, n+1, previous + ln_sum(n, z), delta) 
		endif
	 
	ln_sum(n: Integer, z: Real): Real = 1 / (2*n+1) * power((z-1)/(z+1), 2*n+1)

	incomingAssociations(): Set(Association) = 
			self.incoming->union(self.outgoing->reject(associationDirection = AssociationDirection::One))

	outgoingAssociations(): Set(Association) =
			self.outgoing->union(self.incoming->reject(associationDirection = AssociationDirection::One))

	-- Returns the associations connections from artifacts (textAnnotation, group) to the current baseElement
		associations(): Set(Association) = self.outgoing->union(self.incoming)
						-> select(oclIsKindOf(Association)) -> collect(oclAsType(Association)) -> asSet()

	-- Returns the  artifacts (textAnnotation, group) of the current baseElement
		artifacts(): Set(Artifact) = self.outgoing.targetRef 
						-> union (self.incoming.sourceRef)
						-> select(oclIsKindOf(Artifact)) -> collect(oclAsType(Artifact)) -> asSet()

 	-- abstract implementation to implement in concrete classes
		successors1(): Set(OclAny) = oclUndefined(Set(OclAny))

	-- Returns the baseElements successors of an association of the current node 
	successors(): Set(OclAny) = self.successors_Association()

	-- Returns the baseElements successors of an association of the current node 
	successors_Association(): Set(OclAny) = self.outgoing.targetRef-> union(self.incoming.sourceRef)->asSet()

 end --BaseElement

 abstract class Activity < FlowNode, InteractionNode -- ***** CHANGED added InteractionNode
	attributes
		isForCompensation : Boolean
		startQuantity : Integer
		completionQuantity : Integer
	operations
			-- Returns the sucessors of the current SubProcess
		successors1(): Set(OclAny) = successors1_FlowNode()
									->union(successors1_BoundaryEvent())
									->union(self.dataOutputAssociations)
									->union(self.dataInputAssociations)	-- Inclui também o input

	-- Returns the successors of the current Activity 
	successors_Activity(): Set(OclAny) = self.successors_FlowNode()
															->union(self.successors_BoundaryEvent())
															->union(self.dataElements())->asSet()

	-- Returns the sucessors of boundaryEvents of current Activity 
	successors1_BoundaryEvent(): Set(OclAny) = self.successors_BoundaryEvent()
									->collect(oclAsType(Event).successors1())->asSet()

	-- Returns the nodes boundaryEvents of current Activity 
	successors_BoundaryEvent(): Set(OclAny) = 
												oclEmpty(Set(OclAny))
												->union(self.boundaryEventRefs)->asSet()

	-- abstract implementation to implement in inherited classes of Activity 
	successors(): Set(OclAny) = self.successors_Activity()
									->union(self.successors_BoundaryEvent())->asSet()

	-- returns data sources/drains related with current activity
		dataElements() : Set(ItemAwareElement) = 
									self.dataInputAssociations.sourceRef	-- Inclui também o input
									->union(self.dataOutputAssociations.targetRef)->asSet()

	-- returns connectors to data sources/drains related with current activity
		dataAssociations() : Set(DataAssociation) = self.dataInputAssociations
								->union(self.dataOutputAssociations)->asSet()
	
	-- returns true if the outgoing sequence flows have conditions
		outgoingSequenceFlowsHaveConditions() : Boolean =
		self.outputSequenceFlows()->size() > 1 implies 
									(
									(self.outputSequenceFlows()->size() - 
									self.outputSequenceFlows().conditionExpression
										->select(oclIsKindOf(Expression))
										->select(oclIsTypeOf(FormalExpression))->asSet()->size() <= 1)
									or
									((self.outputSequenceFlows()->size() - 
									self.outputSequenceFlows().conditionExpression
										->select(oclIsKindOf(Expression))
										->select(oclIsTypeOf(FormalExpression))->asSet()->size() > 1)
										and 
									(self.default = oclUndefined(OclVoid)))
									)

	-- returns true if the incoming sequence flows have conditions
	-- or are from exclusive paths
		incomingSequenceFlowsFromExclusivePaths() : Boolean =
									self.inputSequenceFlows()->size() > 1 implies 
									((self.inputSequenceFlows()->size() - 
									self.inputSequenceFlows().conditionExpression
										->select(oclIsKindOf(Expression))
										->select(oclIsTypeOf(FormalExpression))->asSet()->size() <= 1)
									or
									(self.inputSequenceFlows()->select(isExclusive())->size() > 1 and
									(self.inputSequenceFlows()->select(isExclusive())->size() =
										self.inputSequenceFlows()->size())
									))

	-- Returns true if the current Callable Activity is a callable Process
	-- or a callable activity
	isCallActivity(): Boolean =
			(self.oclIsTypeOf(CallActivity))

	-- Returns true if the current Activity is for Compensation
	isForCompensation(): Boolean =
	if (self.oclIsTypeOf(SubProcess)) then
		self.oclAsType(SubProcess).isForCompensationSubProcess()
	else
		(self.isForCompensation.isDefined() and (self.isForCompensation = true))
	endif

	-- Returns true if the current Activity has no Incoming And Outgoing Sequence Flow
	hasNoIncomingAndOutgoingSequenceFlow(): Boolean =
			self.withoutInputSequenceFlows() and
			self.withoutOutputSequenceFlows() 


 end --Activity

 abstract class LoopCharacteristics < BaseElement
 end --LoopCharacteristics

 abstract class Artifact < BaseElement
	operations
	-- returns the successors of the current Artifact (the direction of association is irrelevant)
 		successors1(): Set(OclAny) = self.associations()

	-- returns the elements attached to the current Artifact (the direction of association is irrelevant)
 		successors(): Set(OclAny) = self.outgoing.targetRef->union(self.incoming.sourceRef)->asSet()
 end --Artifact

 abstract class ChoreographyActivity < FlowNode
	attributes
		loopType : ChoreographyLoopType
 end --ChoreographyActivity

 abstract class ConversationNode < BaseElement, InteractionNode
	attributes
		name : String
 end --ConversationNode

 abstract class CallableElement < RootElement
	attributes
		name : String
		

 end --CallableElement

 abstract class FlowElement < BaseElement
	attributes
		name : String
	operations
		
		-- return the pool where a flowElement is located
		pool(element : FlowElement) : Set(Participant) =
				searchPool( element, element.container) 

		-- recursive function that returns the pool of the top flowElement
		searchPool(element : FlowElement, 
				elementContainer : FlowElementsContainer ) : Set(Participant) =
			if elementContainer.isDefined() and elementContainer.oclIsTypeOf(Process) then
					elementContainer.oclAsType(Process).participant
			else
				if element.container.isDefined() then
						searchPool(elementContainer.oclAsType(SubProcess) , 
										elementContainer.oclAsType(SubProcess).container)
				else
						oclEmpty(Set(Participant))
				endif
			endif

		-- return the top Process of the current flowElement
		ownProcess() : Process = topContainer(self)->asOrderedSet()->first()

		-- return the top container of the current flowElement
		topContainer(element : FlowElement) : Set(Process) =
				searchTopContainer( element, element.container) 

		-- recursive function that returns the top container of the flowElement
		searchTopContainer(element : FlowElement, 
				elementContainer : FlowElementsContainer ) : Set(Process) =
			if elementContainer.isDefined() and elementContainer.oclIsTypeOf(Process) then
					oclEmpty(Set(Process))->including(elementContainer.oclAsType(Process))
			else
				if element.container.isDefined() then
						searchTopContainer(elementContainer.oclAsType(SubProcess) , 
										elementContainer.oclAsType(SubProcess).container)
				else
						oclEmpty(Set(Process))
				endif
			endif
 
 end --FlowElement

 abstract class FlowElementsContainer < BaseElement
 
operations


	-- Returns the successors (pool, message flows,) of the current container 
	successors1(): Set(OclAny) = 	self.flowElements->select(oclIsKindOf(FlowNode)) 
																-> select(oclAsType(FlowNode).withoutInputSequenceFlows()) -> asSet()

	-- Returns the elements successors of the current container 
	successors(): Set(OclAny) =	self.flowElements->select(oclIsKindOf(FlowNode)) 
												-> collect(oclAsType(FlowNode).withoutInputSequenceFlows()) -> asSet()

	-- Returns the baseElements successors of an association of the current node 
	successors_Association(): Set(OclAny) = self.outgoing.targetRef-> union(self.incoming.sourceRef)-> asSet()



		-- Função que calcula todos os caminhos possiveis, dando a origem e retorna um conjunto de elementos genéricos (OclAny)
		computePath(origin: OclAny) : Set(Sequence(OclAny)) =
			visitPath(origin, 
				 oclEmpty(Set(OclAny))->including(origin),
				 oclEmpty(Sequence(OclAny))->append(origin),
				 oclEmpty(Set(Sequence(OclAny))))

		visitPath ( x: OclAny, 
					visited: Set(OclAny),
					path: Sequence(OclAny),
					paths: Set(Sequence(OclAny))) : Set(Sequence(OclAny)) =

				let successors: Set(OclAny) = 
					if x.oclIsKindOf(BaseElement) then
						x.oclAsType(BaseElement).successors1()
					else
						x.oclAsType(InteractionNode).successors1()
					endif
				in
					if successors->isEmpty() or visited->includesAll(successors) then
						paths->including(path)
					else
						successors->iterate(elem: OclAny; acc: Set(Sequence(OclAny)) = paths | 
							if visited->excludes(elem) then
								visitPath(elem, visited->including(elem), path->append(elem), acc)
							else
								acc
							endif)
					endif

				-- Função que calcula todos os caminhos possiveis, dando a origem, incluindo artifacts e dataStores/dataObjects
		computeAll(origin: OclAny) : Set(Sequence(OclAny)) =
			visitAll(origin, 
				 oclEmpty(Set(OclAny))->including(origin),
				 oclEmpty(Sequence(OclAny))->append(origin),
				 oclEmpty(Set(Sequence(OclAny))))

		visitAll ( x: OclAny, 
					visited: Set(OclAny),
					path: Sequence(OclAny),
					paths: Set(Sequence(OclAny))) : Set(Sequence(OclAny)) =

				let successors: Set(OclAny) = 
					if x.oclIsKindOf(BaseElement) then
						x.oclAsType(BaseElement).successors()
					else
						x.oclAsType(InteractionNode).successors()
					endif
				in
				if successors->isEmpty() then
						paths->including(path)
				else
						successors->iterate(elem: OclAny; acc: Set(Sequence(OclAny)) = paths | 
							if visited->excludes(elem) then
								visitAll(elem, visited->including(elem), path->append(elem), acc)
							else
								acc
							endif)
				endif

				-- Função que calcula todos os caminhos possiveis, dando a origem, excluindo artifacts e dataStore/dataObject
		computeElements(origin: OclAny) : Set(Sequence(OclAny)) =
			visitElements(origin, 
				 oclEmpty(Set(OclAny))->including(origin),
				 oclEmpty(Sequence(OclAny))->append(origin),
				 oclEmpty(Set(Sequence(OclAny))))

		visitElements( x: OclAny, 
					visited: Set(OclAny),
					path: Sequence(OclAny),
					paths: Set(Sequence(OclAny))) : Set(Sequence(OclAny)) =

				let successors: Set(OclAny) = 
					if x.oclIsKindOf(FlowNode) then
						x.oclAsType(FlowNode).successors2()
					else
						x.oclAsType(InteractionNode).successors2()
					endif
				in
				if successors->isEmpty() then
						paths->including(path)
				else
						successors->iterate(elem: OclAny; acc: Set(Sequence(OclAny)) = paths | 
							if visited->excludes(elem) then
								visitElements(elem, visited->including(elem), path->append(elem), acc)
							else
								acc
							endif)
				endif

				-- Função que calcula todos os caminhos possiveis, dando a origem, incluindo apenas Flow Node, 
				-- no caminho de Sequence Flows
		computeFlowNodes(origin: OclAny) : Set(Sequence(OclAny)) =
			visitFlowNodes(origin, 
				 oclEmpty(Set(OclAny))->including(origin),
				 oclEmpty(Sequence(OclAny))->append(origin),
				 oclEmpty(Set(Sequence(OclAny))))

		visitFlowNodes( x: OclAny, 
					visited: Set(OclAny),
					path: Sequence(OclAny),
					paths: Set(Sequence(OclAny))) : Set(Sequence(OclAny)) =

				let successors: Set(OclAny) =	x.oclAsType(FlowNode).outgoing_a.targetRef->asSet()
				in
				if successors->isEmpty() then
						paths->including(path)
				else
						successors->iterate(elem: OclAny; acc: Set(Sequence(OclAny)) = paths | 
							if visited->excludes(elem) then
								visitFlowNodes(elem, visited->including(elem), path->append(elem), acc)
							else
								acc
							endif)
				endif


		-- Função que,  dado um no, calcula todos os caminhos possiveis até à origem
		-- (excluindo artifacts e dataStore/dataObject)
		computePrecedentElements(origin: OclAny) : Set(Sequence(OclAny)) =
			visitPrecedentElements(origin, 
				 oclEmpty(Set(OclAny))->including(origin),
				 oclEmpty(Sequence(OclAny))->append(origin),
				 oclEmpty(Set(Sequence(OclAny))))

		visitPrecedentElements( x: OclAny, 
					visited: Set(OclAny),
					path: Sequence(OclAny),
					paths: Set(Sequence(OclAny))) : Set(Sequence(OclAny)) =

				let precedents: Set(OclAny) = x.oclAsType(FlowNode).precedents_FlowNode()
				in
				if precedents->isEmpty() then
						paths->including(path)
				else
						precedents->iterate(elem: OclAny; acc: Set(Sequence(OclAny)) = paths | 
							if visited->excludes(elem) then
								visitPrecedentElements(elem, visited->including(elem), path->append(elem), acc)
							else
								acc
							endif)
				endif

		-- Função que calcula todos os caminhos possiveis, dentro do mesmo container,
		-- dando a origem e o destino. Percorre apenas os Sequence Flows
		computeFlowNodePath(origin: OclAny, 
				destination: OclAny) : Set(Sequence(OclAny)) =
			visitFlowNodePath(origin, 
				 destination,
				 oclEmpty(Set(OclAny)),
				 oclEmpty(Sequence(OclAny))->append(origin),
				 oclEmpty(Set(Sequence(OclAny))))
		visitFlowNodePath (x: OclAny, 
				destination: OclAny,
				visited: Set(OclAny),
				path: Sequence(OclAny),
				paths: Set(Sequence(OclAny))) : Set(Sequence(OclAny)) =

				let successors: Set(OclAny) = 
					if x.oclIsKindOf(FlowNode) then
						oclEmpty(Set(OclAny))->union(x.oclAsType(FlowNode).outgoing_a.targetRef)->asSet()
					else
						oclEmpty(Set(OclAny))
					endif
				in
				if x=destination and visited->size() > 0 then
					paths->including(path)
				else
					if successors->isEmpty() then
						paths
					else
						successors->iterate(elem: OclAny; acc: Set(Sequence(OclAny)) = paths | 
							if visited->excludes(elem) then
								visitFlowNodePath(elem, destination, visited->including(elem), path->append(elem), acc)
							else
								acc
							endif)
					endif
				endif


		-- Função que calcula todos os caminhos possiveis, dando a origem e o destino
		compute(origin: OclAny, 
				destination: OclAny) : Set(Sequence(OclAny)) =
			visit(origin, 
				 destination,
				 oclEmpty(Set(OclAny))->including(origin),
				 oclEmpty(Sequence(OclAny))->append(origin),
				 oclEmpty(Set(Sequence(OclAny))))
		visit (x: OclAny, 
				destination: OclAny,
				visited: Set(OclAny),
				path: Sequence(OclAny),
				paths: Set(Sequence(OclAny))) : Set(Sequence(OclAny)) =

				let successors: Set(OclAny) = 
					if x.oclIsKindOf(BaseElement) then
						x.oclAsType(BaseElement).successors()
					else
						x.oclAsType(InteractionNode).successors()
					endif
				in
				if x=destination then
					paths->including(path)
				else
					if successors->isEmpty() then
						paths
					else
						successors->iterate(elem: OclAny; acc: Set(Sequence(OclAny)) = paths | 
							if visited->excludes(elem) then
								visit(elem, destination, visited->including(elem), path->append(elem), acc)
							else
								acc
							endif)
					endif
				endif

		-- Função que retorna o maior caminho. Em caso de empate retorna o primeiro dos maiores caminhos
		biggestPath (origin: OclAny, 
				 destination: OclAny): Sequence(OclAny) = 
				compute(origin, destination) -> iterate(elem: Sequence(OclAny); 
														 acc: Sequence(OclAny) = oclEmpty(Sequence(OclAny)) | 
							if elem->size() > acc->size() then 
								elem
							else
								acc
							endif)

		-- Função que conta o número de objectos do maior caminho de um processo
		sizeBiggestPath(origin: OclAny, 
							 destination: OclAny): Integer = biggestPath(origin, destination) -> size()

		-- Função que retorna o menor caminho. Em caso de empate retorna o último dos menores caminhos
		smallestPath (origin: OclAny, 
				 destination: OclAny): Sequence(OclAny) = 
				compute(origin, destination) -> iterate(elem: Sequence(OclAny); 
														 acc: Sequence(OclAny) = biggestPath(origin, destination)| 
							if elem->size() > acc->size() then 
								acc
							else
								elem
							endif)

		-- Função que conta o número de objectos do menor caminho de um processo
		sizeSmallestPath(origin: OclAny, 
							 destination: OclAny): Integer = smallestPath(origin, destination) -> size()

		-- Função que conta o número de caminhos possiveis de um processo
		numberPaths(origin: OclAny, 
					destination: OclAny): Integer = compute(origin, destination) -> size()

		-- Função que mostra todos os flowNodes dos vários caminhos possiveis de um processo (análise de cobertura)
		allElements(origin: OclAny, 
					destination: OclAny): Set(OclAny) = compute(origin, destination) -> flatten

		-- Função que conta todos os flowNodes dos vários caminhos possiveis de um processo (análise de cobertura)
		countAllElements(origin: OclAny, 
					 destination: OclAny): Integer = allElements(origin, destination) -> size()

		-- Função que conta o número de objectos nos caminhos possiveis de um processo
		sizesOfPaths(origin: OclAny, destination: OclAny): Bag(Integer) = 
				 compute(origin, destination) -> iterate(o; acc: Bag(Integer) = Bag{} |
							acc-> including(o.oclIsKindOf(FlowNode)->count(true)))
		
		-- Função que retorna true se o Container tem Start ou End Events
		hasExplicitStartAndEndEvents() : Boolean =
			totalNumberContainerStartEvents() + totalNumberContainerEndEvents() > 0
			
		-- Função que retorna true se o Container tem Gateways ou Activities
		-- com início ou fim implícito
		implicitStartAndEndEventsFromActivitiesOrGateways() : Boolean =
			((self.totalContainerGateways()->select(withoutInputSequenceFlows())->size() +
				self.totalContainerActivitiesNotForCompensation()->select(withoutInputSequenceFlows())->size() > 0)
				and
			(self.totalContainerActivitiesNotForCompensation()->select(withoutInputSequenceFlows())->size() +
				self.totalContainerGateways()->select(withoutOutputSequenceFlows())->size() > 0))

		
		-- Função que retorna true se o Container tem todas as Gateways e Activities
		-- com Sequence Flows de entrada e saída
		allActivitiesAndGatewaysHaveIncomingAndOutgoing() : Boolean =
				(
				self.totalContainerGateways()->forAll(hasInputSequenceFlows() and hasOutputSequenceFlows())
				and
				self.totalContainerActivitiesNotForCompensation()->forAll(hasInputSequenceFlows()and hasOutputSequenceFlows())
				)

		-- Função que retorna o número de untyped start events
		totalNumberContainerNoneStartEvents() : Integer =
			self.totalContainerStartEvents()->reject(eventDefinitions->notEmpty())->size() 
		
		-- Função que retorna o número de typed start events
		totalNumberContainerTypedStartEvents() : Integer =
			self.totalContainerStartEvents()->select(eventDefinitions->notEmpty())->size() 
		
		-- Função que retorna true se houver start e end events no container
		existsExplicitStartAndEndEvents() : Boolean =
		(bpmnElements()->reject(oclIsTypeOf(BoundaryEvent))->size() > 0) implies
		((self.totalNumberContainerEndEvents() > 0) and 
			(self.totalNumberContainerStartEvents() > 0))
		
		-- Função que retorna true se os start e end events no container
		-- foram substituídos por actividades e gateways
		existsImplicitStartAndEndEvents() : Boolean =
				((bpmnElements()->reject(oclIsTypeOf(BoundaryEvent))->size() > 0) and
			(self.totalNumberContainerEndEvents() + self.totalNumberContainerStartEvents() = 0))
	implies
			implicitStartAndEndEventsFromActivitiesOrGateways()
	
	
		-- Função que retorna true se os intermediate events do container
		-- (com excepção dos Link Event) tiverem incoming e outgoing sequence flows
		intermediateEventsHaveIncAndOutSeqFlows() : Boolean = self.totalContainerIntermediateCatchEvents()
												->reject(isLinkEvent())
			->union(self.totalContainerIntermediateThrowEvents()->reject(isLinkEvent())->asSet())
			->forAll(numberInputSequenceFlows() > 0  and numberOutputSequenceFlows() > 0)

		-- Função que retorna true se os conjuntos dos nomes dos catch/throw 
		-- Link Event do container coincidirem
		matchInNamesOfCatchAndThrowLinkEvent() : Boolean = 
							(self.totalContainerIntermediateCatchEvents()
												->select(isLinkEvent())->collect(name)->asSet()) = 
			(self.totalContainerIntermediateThrowEvents()->select(isLinkEvent())->collect(name)->asSet())


	-- Returns true if the name of targets Link Event are unique 
		nameOfCatchLinkEventsIsUnique() : Boolean = 
							(self.totalContainerIntermediateCatchEvents()
												->select(isLinkEvent())->isUnique(name))

		-- Função que retorna true se os end events do container
		-- não tiverem outgoing sequence flow
		endEventsHaveNoOutgoingSequenceFlow() : Boolean =
		self.totalContainerEndEvents()
													->forAll(numberOutputSequenceFlows() = 0)
	
	-- The non-interrupting variants of the start events (message, conditional, escalation,
	-- timer, signal, multiple, and parallel multiple events) are only possible 
	-- within an event sub-process, but not in a normal process. **********
		nonInterruptingStartEventsOnlyInEventSubProcess() : Boolean =
		(self.totalContainerStartEvents()
				->select(isNonInterruptingEvent())->notEmpty()) 
		implies
		(self.oclIsKindOf(SubProcess) 
			and self.oclAsType(SubProcess).isEventSubProcess())


		-- Função que retorna true se existirem start/end events no container
		-- e não existirem actividades/gateways sem incoming sequence flow
		explicitStartWithoutNodesWithIncomingSequenceFlow() : Boolean =
			(self.totalNumberContainerEndEvents() + self.totalNumberContainerStartEvents() > 0
		implies
			allActivitiesAndGatewaysHaveIncomingAndOutgoing())
		

		-- Função que retorna true se existirem  actividades/gateways sem incoming 
		-- sequence flow no container, e não existirem start/end events 
		existsOnlyImplicitStartEvent() : Boolean =
			(((self.flowElements
				->select(oclIsKindOf(Activity))
				->select(oclAsType(FlowNode).withoutInputSequenceFlows())
				->asSet()) -
				(self.flowElements->select(oclAsType(Activity).isForCompensation = true)
					->union(self.flowElements->select(oclAsType(SubProcess).triggeredByEvent = true))))
				->size() > 0
			or
			self.flowElements->select(oclIsKindOf(Gateway))
				->select(oclAsType(FlowNode).withoutInputSequenceFlows())
				->asSet()
				->size() > 0)
			implies
				self.totalContainerEvents()->select(oclIsKindOf(StartEvent))-> size() = 0

		-- Função que retorna true se não existir  gateways com incoming and outgoing
		-- simultaneamente
		noGatewayWithSeveralInputsAndSeveralOutputs() : Boolean =
		not (self.totalContainerGateways()->exists(numberInputSequenceFlows() > 1 
		and numberOutputSequenceFlows() > 1 ))
	
	
		-- Função que retorna true se (não existirem start/end events)
		noStartOrEndEvents() : Boolean =
		(self.totalNumberContainerStartEvents()=0 implies self.totalNumberContainerEndEvents()=0)
	and 
		(self.totalNumberContainerEndEvents()=0 implies self.totalNumberContainerStartEvents()=0)


	-- When activities that are not part of a transaction have compensation
	-- activities, these compensations must be explicitly called with a
	-- labeled or unlabeled throwing compensation event, because they cannot
	-- be triggered by aborting a transaction.
		isCompensationActivityPartOfNonTransaction() : Boolean =
	(not self.oclIsTypeOf(Transaction)) and
	(self.totalContainerActivities().boundaryEventRefs->select(isCompensateEvent())->size()>0)
	implies
	((self.totalContainerEndEvents()->select(isCompensateEvent())->size() +
	self.totalContainerIntermediateThrowEvents()->select(isCompensateEvent())->size() > 0)
	or
	self.bpmnFlowNodesDataElements(self)->flatten()
					->select(oclIsKindOf(SubProcess))
					->select(oclAsType(SubProcess).startsACompensation())
					->size() > 0
		)

		nameOfThrowingCompensationEventMatchNameOfCancelledActivity() : Boolean =
	-- The name of a throwing intermediate compensation event
	-- must match to the name of one of the activities that can be cancelled
	-- event subprocess that starts .
	not oclAsType(SubProcess).isTransactionSubProcess()
	implies
	(
	(self.myProcess().bpmnFlowNodesDataElements(self.myProcess())
						->flatten()->select(oclIsKindOf(ThrowEvent))
						->select(oclAsType(ThrowEvent).isCompensateEvent() 
												and oclAsType(ThrowEvent).name.isDefined())
						->collect(oclAsType(ThrowEvent).name)->asSet())
			-
	(self.myProcess().bpmnFlowNodesDataElements(self.myProcess())
						->flatten()->select(oclIsKindOf(Activity))
						->collect(oclAsType(Activity).boundaryEventRefs)
						->select(isCompensateEvent())
						->collect(oclAsType(BoundaryEvent).attachedToRef.name)->asSet())
			- 
	(self.myProcess().bpmnFlowNodesDataElements(self.myProcess())
						->flatten()->select(oclIsTypeOf(SubProcess))
						->select(oclAsType(SubProcess).startsACompensation())
						->collect(oclAsType(FlowElementsContainer).totalContainerStartEvents())
						->select(isCompensateEvent() and name.isDefined())
						->collect(oclAsType(StartEvent).name)->asSet())
		)->size() = 0


		-- return the top Process of the current flowElementContainer
		myProcess() : Process = myContainer(self)->asOrderedSet()->first()

		-- return the top container of the current flowElementContainer
		myContainer(element : FlowElementsContainer) : Set(Process) =
			if element.oclIsTypeOf(Process) then 
				oclEmpty(Set(Process))->including(element.oclAsType(Process))
			else
				if element.oclIsTypeOf(SubProcess) then 
					oclEmpty(Set(Process))
								->including(element.oclAsType(SubProcess).ownProcess())
				else
					oclEmpty(Set(Process))
				endif
			endif
			
		-- Any Process that does not have a parent Process is considered a
		-- top-level Process (page 238), i.e., a Process that is not a
		-- Sub-Process is a top-level Process. 
		isTopLevelProcess() : Boolean =
			self.oclIsTypeOf(Process) -- Falta refereência a Reusable SubProcess
		-- TO DO
		
		-- It is not allowed to have isolated Flow Nodes, so they must have
	-- one incoming or one outgoing sequence flow (page ???).
	hasIncomingOrOutgoingSequenceFlow() : Boolean =
		not ((self.totalContainerFlowNodes()
		-
				 self.totalContainerSubProcesses()->select(isEventSubProcess())
		-
				 self.totalContainerActivities()->select(isForCompensation())
		-
		self.totalContainerCatchEvents()->select(isCompensateEvent()))
			->exists(numberInputSequenceFlows() = 0 
					and numberOutputSequenceFlows() = 0))


	-- Use only 7± 2 Flow Nodes per diagram
  -- TO DO
  withinLimitOfFlowNodesPerDiagram(): Boolean = true

  -- Use Send/Receive Task or Throw/Catch Message Intermediate Events (not both)
  -- TO DO
		isSendReceiveTaskExclusivedUse(): Boolean = true
	
	-- It is recommended that only one Start Event be used
  -- TO DO
    existsOnlyOneStartEvent(): Boolean = true

  -- An Exclusive or Event Gateway should have at most one unnamed outgoing Sequence Flow
  -- TO DO
    noMoreThanOneUnnamedSequenceFlow(): Boolean = true

  -- An Inclusive Gateway should have all outgoing Sequence Flow named 
  -- TO DO
    notExistsUnnamedSequenceFlow(): Boolean = true

  -- If a SubProcess is followed by a yes/no Gateway, at least one End Event 
  -- of the SubProcess should be named to match the Gateway name 
  -- TO DO
    matchEndEventAndGatewayName(): Boolean = true

	-- Activities should be named
  -- TO DO
    isActivityNamed(): Boolean = true

	-- If a SubProcess is followed by a Gateway labeled as a question, 
	-- it must have more than one End Event
  -- TO DO
    hasMoreThanOneEndEvent(): Boolean = true


		------------------------ Origem sem connectores, dataObject/dataStore e artifacts ---------------------------------------------------

		-- Função que retorna o maior caminho. Em caso de empate retorna o primeiro dos maiores caminhos
		biggestPathO (origin: OclAny): Sequence(OclAny) = 
				computeElements(origin) -> iterate(elem: Sequence(OclAny); 
														 acc: Sequence(OclAny) = oclEmpty(Sequence(OclAny)) | 
							if elem->size() > acc->size() then 
								elem
							else
								acc
							endif)

		-- Função que conta o número de objectos do maior caminho de um processo
		sizeBiggestPathO(origin: FlowNode): Integer = biggestPathO(origin) -> size()

		-- Função que retorna o menor caminho. Em caso de empate retorna o último dos menores caminhos
		smallestPathO (origin: OclAny): Sequence(OclAny) = 
				computeElements (origin) -> iterate(elem: Sequence(OclAny); 
														 acc: Sequence(OclAny) = biggestPathO(origin)| 
							if elem->size() > acc->size() then 
								acc
							else
								elem
							endif)

		-- Função que conta o número de objectos do menor caminho de um processo
		sizeSmallestPathO(origin: FlowNode): Integer = smallestPathO(origin) -> size()

				-- Função que conta o número de caminhos possiveis de um processo
		numberPathsO(origin: FlowNode): Integer = computeElements(origin) -> size()

		-- Função que mostra todos os elementos dos vários caminhos possiveis de um processo (análise de cobertura)
		allElementsO(origin: FlowNode): Set(OclAny) = computeElements(origin) -> flatten

		-- Função que conta todos os elementos dos vários caminhos possiveis de um processo (análise de cobertura)
		countAllElementsO(origin: FlowNode): Integer = allElementsO(origin) ->  size()

		-- Função que conta o número de elementos nos caminhos possiveis de um processo
		sizeOfPathsO(origin: FlowNode): Bag(Integer) = 
				computeElements(origin) -> iterate(o; acc: Bag(Integer) = Bag{} |
							acc-> including(o.oclIsKindOf(FlowNode)->count(true)))

		------------------------------ Origem com connectores, dataObject/dataStore e artifacts ---------------------------------------------------
		-- Função que retorna o maior caminho. Em caso de empate retorna o primeiro dos maiores caminhos
		biggestPath_ (origin: OclAny): Sequence(OclAny) = 
				computePath(origin) -> iterate(elem: Sequence(OclAny); 
														 acc: Sequence(OclAny) = oclEmpty(Sequence(OclAny)) | 
							if elem->size() > acc->size() then 
								elem
							else
								acc
							endif)

		-- Função que conta o número de objectos do maior caminho de um processo
		sizeBiggestPath_(origin: OclAny): Integer = biggestPath_(origin) -> size()

		-- Função que retorna o menor caminho. Em caso de empate retorna o último dos menores caminhos
		smallestPath_ (origin: OclAny): Sequence(OclAny) = 
				computePath (origin) -> iterate(elem: Sequence(OclAny); 
														 acc: Sequence(OclAny) = biggestPath_(origin)| 
							if elem->size() > acc->size() then 
								acc
							else
								elem
							endif)

		-- Função que conta o número de objectos do menor caminho de um processo
		sizeSmallestPath_(origin: OclAny): Integer = smallestPath_(origin) -> size()

		-- Função que conta o número de caminhos possiveis de um processo
		numberPaths_(origin: OclAny): Integer = computePath(origin) -> size()

		-- Função que mostra todos os elementos dos vários caminhos possiveis de um processo (análise de cobertura)
		allElements_(origin: OclAny): Set(OclAny) = computePath(origin) -> flatten

		-- Função que conta todos os elementos dos vários caminhos possiveis de um processo (análise de cobertura)
		countAllElements_(origin: OclAny): Integer = allElements_(origin) ->  size()

		-- Função que conta o número de elementos nos caminhos possiveis de um processo
		sizesOfPaths_(origin: OclAny): Bag(Integer) =
				computePath(origin) -> iterate(o; acc: Bag(Integer) = Bag{} |
							acc-> including(o.oclIsKindOf(OclAny)->count(true)))

--------------------------------------------------------------------------------------------------
		-- Função que percorre um dado caminho com uma origem e um destino e conta o número total de FlowNodes (gateways, activities e events) de um processo
		countFlowNodes(origin: FlowNode, destination: FlowNode) : Integer = seeFlowNodes(origin, destination) ->size()

		-- Função que percorre um dado caminho com uma origem e um destino e mostra todos os flowNodes de um processo
		seeFlowNodes(origin: FlowNode, 
					 destination: FlowNode) : Set(FlowNode) = compute(origin, destination) -> flatten ->
										select(oclIsKindOf(FlowNode))->collect(oclAsType(FlowNode)) -> asSet()

		-- Função que percorre um dado caminho com uma origem e um destino e conta o número de actividades
		countActivities(origin: FlowNode, destination: FlowNode) : Integer = seeActivities(origin, destination) ->size()

		-- Função que percorre um dado caminho com uma origem e um destino e mostra as actividades contidas nesse caminho
		seeActivities(origin: FlowNode, 
					 destination: FlowNode) : Set(Activity) = compute(origin, destination) -> flatten ->
										 select(oclIsKindOf(Activity))->collect(oclAsType(Activity)) -> asSet()

		-- Função que percorre um dado caminho com uma origem e um destino e conta o número de tasks
		countTasks(origin: FlowNode, destination: FlowNode) : Integer = seeTasks(origin, destination) -> size()

		-- Função que percorre um dado caminho com uma origem e um destino e mostra as tasks contidas nesse caminho
		seeTasks(origin: FlowNode, 
					 destination: FlowNode) : Set(Task) = compute(origin, destination) -> flatten ->
										 select(oclIsKindOf(Task))->collect(oclAsType(Task)) -> asSet()

		-- Função que percorre um dado caminho com uma origem e um destino e conta o número de subprocessos
		countSubprocesses(origin: FlowNode, destination: FlowNode) : Integer = seeSubprocesses(origin, destination) -> size()

		-- Função que percorre um dado caminho com uma origem e um destino e mostra os subprocessos contidos nesse caminho
		seeSubprocesses(origin: FlowNode, 
					 destination: FlowNode) : Set(SubProcess) = compute(origin, destination) -> flatten ->
										 select(oclIsKindOf(SubProcess))->collect(oclAsType(SubProcess)) -> asSet()

		-- Função que percorre um dado caminho com uma dada origem e conta o número total de FlowNodes (gateways, activities e events) de um processo
		countFlowNodesO(origin: FlowNode) : Integer = seeFlowNodesO(origin) -> size()

		-- Função que percorre um dado caminho com uma dada origem e conta o número total de FlowNodes (activities e events) de um processo
		countActivitiesEventsO(origin: FlowNode) : Integer = countFlowNodesO(origin) - countGatewaysO(origin)

		-- Função que percorre um dado caminho com uma dada origem e mostra todos os flowNodes de um processo
		seeFlowNodesO(origin: FlowNode) : Set(FlowNode) = computeElements(origin) -> flatten ->
										select(oclIsKindOf(FlowNode))->collect(oclAsType(FlowNode)) -> asSet()

		-- Função que percorre um dado caminho com uma origem e conta o número de actividades
		countActivitiesO(origin: FlowNode) : Integer = seeActivitiesO(origin) -> size()

		-- Função que percorre um dado caminho com uma origem e mostra as actividades contidas nesse caminho
		seeActivitiesO(origin: FlowNode) : Set(Activity) = computeElements(origin) -> flatten ->
										 select(oclIsKindOf(Activity))->collect(oclAsType(Activity)) -> asSet()

		-- Função que percorre um dado caminho com uma origem e conta o número de tasks
		countTasksO(origin: FlowNode) : Integer = seeTasksO(origin) ->size()

		-- Função que percorre um dado caminho com uma origem e mostra as tasks contidas nesse caminho
		seeTasksO(origin: FlowNode) : Set(Task) = computeElements(origin) -> flatten ->
										 select(oclIsKindOf(Task))->collect(oclAsType(Task)) -> asSet()

		-- Função que percorre um dado caminho com uma origem e conta o número de subprocessos
		countSubprocessesO(origin: FlowNode) : Integer = seeSubprocessesO(origin) ->size()

		-- Função que percorre um dado caminho com uma origem e mostra os subprocessos contidos nesse caminho
		seeSubprocessesO(origin: FlowNode) : Set(SubProcess) = computeElements(origin) -> flatten ->
										 select(oclIsKindOf(SubProcess))->collect(oclAsType(SubProcess)) -> asSet()

		-- Função que percorre um dado caminho com uma origem e um destino e conta o número de gateways
		countGateways(origin: FlowNode, destination: FlowNode) : Integer = seeGateways(origin, destination) ->size()

		-- Função que percorre um dado caminho com uma origem e um destino e mostra as gateways contidas nesse caminho
		seeGateways(origin: FlowNode, destination: FlowNode) : Set(Gateway) = compute(origin, destination) -> flatten ->
										select(oclIsKindOf(Gateway))->collect(oclAsType(Gateway)) -> asSet()

		-- Função que percorre um dado caminho com uma dada origem e conta o número de gateways
		countGatewaysO(origin: FlowNode) : Integer = seeGatewaysO(origin) -> size()

		-- Função que percorre um dado caminho com uma dada origem e mostra as gateways contidas nesse caminho
		seeGatewaysO(origin: FlowNode) : Set(Gateway) = computeElements(origin) -> flatten ->
										 select(oclIsKindOf(Gateway))->collect(oclAsType(Gateway)) -> asSet()

		-- Função que percorre um dado caminho com uma origem e um destino e conta o número total de EventBasedGateways de um processo 
		countEventBasedGateways(origin: FlowNode, destination: FlowNode) : Integer = seeEventBasedGateways(origin, destination) -> size()

		-- Função que percorre um dado caminho com uma origem e um destino e mostra todos as EventBasedGateways de um processo
		seeEventBasedGateways(origin: FlowNode, 
					 destination: FlowNode) : Set(EventBasedGateway) = compute(origin, destination) -> flatten ->
										select(oclIsKindOf(EventBasedGateway))->collect(oclAsType(EventBasedGateway)) -> asSet()

		-- Função que percorre um dado caminho com uma dada origem e conta o número total de EventBasedGateways de um processo 
		countEventBasedGatewaysO(origin: FlowNode) : Integer = seeEventBasedGatewaysO(origin) -> size()

		-- Função que percorre um dado caminho com uma dada origem e mostra todos as EventBasedGateways de um processo
		seeEventBasedGatewaysO(origin: FlowNode) : Set(EventBasedGateway) = computeElements(origin) -> flatten ->
										select(oclIsKindOf(EventBasedGateway))->collect(oclAsType(EventBasedGateway)) -> asSet()

		-- Função que percorre um dado caminho com uma origem e um destino e conta o número total de ExclusiveGateways de um processo 
		countExclusiveGateways(origin: FlowNode, destination: FlowNode) : Integer = seeExclusiveGateways(origin, destination) -> size()

		-- Função que percorre um dado caminho com uma origem e um destino e mostra todos as ExclusiveGateways de um processo
		seeExclusiveGateways(origin: FlowNode, 
					 destination: FlowNode) : Set(ExclusiveGateway) = compute(origin, destination) -> flatten ->
										select(oclIsKindOf(ExclusiveGateway))->collect(oclAsType(ExclusiveGateway)) -> asSet()

		-- Função que percorre um dado caminho com uma dada origem e conta o número total de ExclusiveGateways de um processo 
		countExclusiveGatewaysO(origin: FlowNode) : Integer = seeExclusiveGatewaysO(origin) -> size()

		-- Função que percorre um dado caminho com uma dada origem e mostra todos as ExclusiveGateways de um processo
		seeExclusiveGatewaysO(origin: FlowNode) : Set(ExclusiveGateway) = computeElements(origin) -> flatten ->
										select(oclIsKindOf(ExclusiveGateway))->collect(oclAsType(ExclusiveGateway)) -> asSet()

		-- Função que percorre um dado caminho com uma origem e um destino e conta o número total de InclusiveGateways de um processo 
		countInclusiveGateways(origin: FlowNode, destination: FlowNode) : Integer = seeInclusiveGateways(origin, destination) -> size()

		-- Função que percorre um dado caminho com uma origem e um destino e mostra todos as InclusiveGateways de um processo
		seeInclusiveGateways(origin: FlowNode, 
					 destination: FlowNode) : Set(InclusiveGateway) = compute(origin, destination) -> flatten ->
										select(oclIsKindOf(InclusiveGateway))->collect(oclAsType(InclusiveGateway)) -> asSet()

		-- Função que percorre um dado caminho com uma dada origem e conta o número total de InclusiveGateways de um processo 
		countInclusiveGatewaysO(origin: FlowNode) : Integer = seeInclusiveGatewaysO(origin) -> size()

		-- Função que percorre um dado caminho com uma dada origem e mostra todos as InclusiveGateways de um processo
		seeInclusiveGatewaysO(origin: FlowNode) : Set(InclusiveGateway) = computeElements(origin) -> flatten ->
										select(oclIsKindOf(InclusiveGateway))->collect(oclAsType(InclusiveGateway)) -> asSet()

		-- Função que percorre um dado caminho com uma origem e um destino e conta o número total de ParallelGateways de um processo 
		countParallelGateways(origin: FlowNode, destination: FlowNode) : Integer = seeParallelGateways(origin, destination) ->size()

		-- Função que percorre um dado caminho com uma origem e um destino e mostra todos as ParallelGateways de um processo
		seeParallelGateways(origin: FlowNode, 
					 destination: FlowNode) : Set(ParallelGateway) = compute(origin, destination) -> flatten ->
										select(oclIsKindOf(ParallelGateway))->collect(oclAsType(ParallelGateway)) -> asSet()

		-- Função que percorre um dado caminho com uma dada origem e conta o número total de ParallelGateways de um processo 
		countParallelGatewaysO(origin: FlowNode) : Integer = seeParallelGatewaysO(origin) -> size()

		-- Função que percorre um dado caminho com uma dada origem e mostra todos as ParallelGateways de um processo
		seeParallelGatewaysO(origin: FlowNode) : Set(ParallelGateway) = computeElements(origin) -> flatten ->
										select(oclIsKindOf(ParallelGateway))->collect(oclAsType(ParallelGateway)) -> asSet()

		-- Função que percorre um dado caminho com uma origem e um destino e conta o número total de ComplexGateways de um processo 
		countComplexGateways(origin: FlowNode, destination: FlowNode) : Integer = seeComplexGateways(origin, destination) -> size()

		-- Função que percorre um dado caminho com uma origem e um destino e mostra todos as ComplexGateways de um processo
		seeComplexGateways(origin: FlowNode, 
					 destination: FlowNode) : Set(ComplexGateway) = compute(origin, destination) -> flatten ->
										select(oclIsKindOf(ComplexGateway))->collect(oclAsType(ComplexGateway)) -> asSet()

		-- Função que percorre um dado caminho com uma dada origem e conta o número total de ComplexGateways de um processo 
		countComplexGatewaysO(origin: FlowNode) : Integer = seeComplexGatewaysO(origin) -> size()

		-- Função que percorre um dado caminho com uma dada origem e mostra todos as ComplexGateways de um processo
		seeComplexGatewaysO(origin: FlowNode) : Set(ComplexGateway) = computeElements(origin) -> flatten ->
										select(oclIsKindOf(ComplexGateway))->collect(oclAsType(ComplexGateway)) -> asSet()

		-- Função que percorre um dado caminho com uma origem e conta o número de gates
		countGatesO(origin: FlowNode) : Integer = seeGatesO(origin)->size()

		-- Função que percorre um dado caminho com uma origem e mostra as gates contidas nesse caminho
		seeGatesO(origin: FlowNode) : Set(SequenceFlow) = seeInputGatesO(origin) ->union(seeOutputGatesO(origin)) -> asSet()
										 
		-- Função que percorre um dado caminho com uma origem e conta o número de gates de input
		countInputGatesO(origin: FlowNode) : Integer = computeAll(origin) -> flatten
																->select(oclIsKindOf(Gateway)).oclAsType(Gateway)->asSet()
																->collect(numberInputSequenceFlows())->sum()

		-- Função que percorre um dado caminho com uma origem e mostra as gates de input contidas nesse caminho
		seeInputGatesO(origin: FlowNode) : Set(SequenceFlow) = computeAll(origin) -> flatten 
																 	->select(oclIsKindOf(Gateway))
																	->collect(oclAsType(Gateway)).inputSequenceFlows() -> asSet()

		-- Função que percorre um dado caminho com uma origem e conta o número de gates de output
		countOutputGatesO(origin: FlowNode) : Integer = computeAll(origin) -> flatten 
																->select(oclIsKindOf(Gateway)).oclAsType(Gateway)->asSet->
																 collect(numberOutputSequenceFlows())->sum()

		-- Função que percorre um dado caminho com uma origem e mostra as gates de output contidas nesse caminho
		seeOutputGatesO(origin: FlowNode) : Set(SequenceFlow) = computeAll(origin) -> flatten 
																 ->select(oclIsKindOf(Gateway))
																	->collect(oclAsType(Gateway)).outputSequenceFlows() -> asSet()

		-- Função que percorre um dado caminho com uma origem e um destino e conta o número de eventos
		countEvents(origin: FlowNode, destination: FlowNode) : Integer = seeEvents(origin, destination) -> size()

		-- Função que percorre um dado caminho com uma origem e um destino e mostra os eventos contidos nesse caminho
		seeEvents(origin: FlowNode, 
					 destination: FlowNode) : Set(Event) = compute(origin, destination) -> flatten ->
										 select(oclIsKindOf(Event))->collect(oclAsType(Event)) -> asSet()

		-- Função que percorre um dado caminho com uma origem e conta o número de eventos
		countEventsO(origin: FlowNode) : Integer = computeElements(origin) -> flatten ->
										 select(oclIsKindOf(Event))->collect(oclAsType(Event))->size()

		-- Função que percorre um dado caminho com uma origem e mostra os eventos contidos nesse caminho
		seeEventsO(origin: FlowNode) : Set(Event) = computeElements(origin) -> flatten ->
										 select(oclIsKindOf(Event))->collect(oclAsType(Event)) -> asSet()

		-- Função que percorre um dado caminho com uma origem e um destino e conta o número de ThrowEvents
		countThrowEvents(origin: FlowNode, destination: FlowNode) : Integer = seeThrowEvents(origin, destination) -> size()

		-- Função que percorre um dado caminho com uma origem e um destino e mostra os ThrowEvent contidos nesse caminho
		seeThrowEvents(origin: FlowNode, 
					 destination: FlowNode) : Set(Event) = compute(origin, destination) -> flatten ->
										 select(oclIsKindOf(ThrowEvent))->collect(oclAsType(ThrowEvent)) -> asSet()

		-- Função que percorre um dado caminho com uma origem e conta o número de ThrowEvent
		countThrowEventsO(origin: FlowNode) : Integer = seeThrowEventsO(origin) -> size()

		-- Função que percorre um dado caminho com uma origem e mostra os ThrowEvent contidos nesse caminho
		seeThrowEventsO(origin: FlowNode) : Set(Event) = computeElements(origin) -> flatten ->
										 select(oclIsKindOf(ThrowEvent))->collect(oclAsType(ThrowEvent)) -> asSet()

		-- Função que percorre um dado caminho com uma origem e um destino e conta o número de EndEvents
		countEndEvents(origin: FlowNode, destination: FlowNode) : Integer = seeEndEvents(origin, destination) -> size()

		-- Função que percorre um dado caminho com uma origem e um destino e mostra os EndEvent contidos nesse caminho
		seeEndEvents(origin: FlowNode, 
					 destination: FlowNode) : Set(Event) = compute(origin, destination) -> flatten ->
										 select(oclIsKindOf(EndEvent))->collect(oclAsType(EndEvent)) -> asSet()

		-- Função que percorre um dado caminho com uma origem e conta o número de EndEvent
		countEndEventsO(origin: FlowNode) : Integer = computeElements(origin) -> flatten ->
										 select(oclIsKindOf(EndEvent))->collect(oclAsType(EndEvent))->size()

		-- Função que percorre um dado caminho com uma origem e mostra os EndEvent contidos nesse caminho
		seeEndEventsO(origin: FlowNode) : Set(Event) = computeElements(origin) -> flatten ->
										 select(oclIsKindOf(EndEvent))->collect(oclAsType(EndEvent)) -> asSet()

		-- Função que percorre um dado caminho com uma origem e um destino e conta o número de IntermediateThrowEvents
		countIntermediateThrowEvents(origin: FlowNode, destination: FlowNode) : Integer = 
										seeIntermediateThrowEvents(origin, destination) -> flatten ->size()

		-- Função que percorre um dado caminho com uma origem e um destino e mostra os IntermediateThrowEvent contidos nesse caminho
		seeIntermediateThrowEvents(origin: FlowNode, 
					 destination: FlowNode) : Set(Event) = compute(origin, destination) -> flatten ->
										 select(oclIsKindOf(IntermediateThrowEvent))->collect(oclAsType(IntermediateThrowEvent)) -> asSet()

		-- Função que percorre um dado caminho com uma origem e conta o número de IntermediateThrowEvent
		countIntermediateThrowEventsO(origin: FlowNode) : Integer = seeIntermediateThrowEventsO(origin) -> size()

		-- Função que percorre um dado caminho com uma origem e mostra os IntermediateThrowEvent contidos nesse caminho
		seeIntermediateThrowEventsO(origin: FlowNode) : Set(Event) = computeElements(origin) -> flatten ->
										 select(oclIsKindOf(IntermediateThrowEvent))->collect(oclAsType(IntermediateThrowEvent)) -> asSet()

		-- Função que percorre um dado caminho com uma origem e um destino e conta o número de ImplicitThrowEvents
		countImplicitThrowEvents(origin: FlowNode, destination: FlowNode) : Integer = seeImplicitThrowEvents(origin, destination) -> size()

		-- Função que percorre um dado caminho com uma origem e um destino e mostra os ImplicitThrowEvent contidos nesse caminho
		seeImplicitThrowEvents(origin: FlowNode, 
					 destination: FlowNode) : Set(Event) = compute(origin, destination) -> flatten ->
										 select(oclIsKindOf(ImplicitThrowEvent))->collect(oclAsType(ImplicitThrowEvent)) -> asSet()

		-- Função que percorre um dado caminho com uma origem e conta o número de ImplicitThrowEvent
		countImplicitThrowEventsO(origin: FlowNode) : Integer = seeImplicitThrowEventsO(origin) -> size()

		-- Função que percorre um dado caminho com uma origem e mostra os ImplicitThrowEvent contidos nesse caminho
		seeImplicitThrowEventsO(origin: FlowNode) : Set(Event) = computeElements(origin) -> flatten ->
										 select(oclIsKindOf(ImplicitThrowEvent))->collect(oclAsType(ImplicitThrowEvent)) -> asSet()

		-- Função que percorre um dado caminho com uma origem e um destino e conta o número de CatchEvents
		countCatchEvents(origin: FlowNode, destination: FlowNode) : Integer = seeCatchEvents(origin, destination) -> size()

		-- Função que percorre um dado caminho com uma origem e um destino e mostra os CatchEvent contidos nesse caminho
		seeCatchEvents(origin: FlowNode, 
					 destination: FlowNode) : Set(Event) = compute(origin, destination) -> flatten ->
										 select(oclIsKindOf(CatchEvent))->collect(oclAsType(CatchEvent)) -> asSet()

		-- Função que percorre um dado caminho com uma origem e conta o número de CatchEvent
		countCatchEventsO(origin: FlowNode) : Integer = seeCatchEventsO(origin) -> size()

		-- Função que percorre um dado caminho com uma origem e mostra os CatchEvent contidos nesse caminho
		seeCatchEventsO(origin: FlowNode) : Set(Event) = computeElements(origin) -> flatten ->
										 select(oclIsKindOf(CatchEvent))->collect(oclAsType(CatchEvent)) -> asSet()

		-- Função que percorre um dado caminho com uma origem e um destino e conta o número de StartEvents
		countStartEvents(origin: FlowNode, destination: FlowNode) : Integer = seeStartEvents(origin, destination)->size()

		-- Função que percorre um dado caminho com uma origem e um destino e mostra os StartEvent contidos nesse caminho
		seeStartEvents(origin: FlowNode, 
					 destination: FlowNode) : Set(Event) = compute(origin, destination) -> flatten ->
										 select(oclIsKindOf(StartEvent))->collect(oclAsType(StartEvent)) -> asSet()

		-- Função que percorre um dado caminho com uma origem e conta o número de StartEvent
		countStartEventsO(origin: FlowNode) : Integer = seeStartEventsO(origin) ->size()

		-- Função que percorre um dado caminho com uma origem e mostra os StartEvent contidos nesse caminho
		seeStartEventsO(origin: FlowNode) : Set(Event) = computeElements(origin) -> flatten ->
										 select(oclIsKindOf(StartEvent))->collect(oclAsType(StartEvent)) -> asSet()

		-- Função que percorre um dado caminho com uma origem e um destino e conta o número de IntermediateCatchEvents
		countIntermediateCatchEvents(origin: FlowNode, destination: FlowNode) : Integer = 
																				seeIntermediateCatchEvents(origin, destination) -> size()

		-- Função que percorre um dado caminho com uma origem e um destino e mostra os IntermediateCatchEvent contidos nesse caminho
		seeIntermediateCatchEvents(origin: FlowNode, 
					 destination: FlowNode) : Set(Event) = compute(origin, destination) -> flatten ->
										 select(oclIsKindOf(IntermediateCatchEvent))->collect(oclAsType(IntermediateCatchEvent)) -> asSet()

		-- Função que percorre um dado caminho com uma origem e conta o número de IntermediateCatchEvent
		countIntermediateCatchEventsO(origin: FlowNode) : Integer = seeIntermediateCatchEventsO(origin) -> size()

		-- Função que percorre um dado caminho com uma origem e mostra os IntermediateCatchEvent contidos nesse caminho
		seeIntermediateCatchEventsO(origin: FlowNode) : Set(Event) = computeElements(origin) -> flatten ->
										 select(oclIsKindOf(IntermediateCatchEvent))->collect(oclAsType(IntermediateCatchEvent)) -> asSet()

		-- Função que percorre um dado caminho com uma origem e um destino e conta o número de BoundaryEvents
		countBoundaryEvents(origin: FlowNode, destination: FlowNode) : Integer = seeBoundaryEvents(origin, destination) -> size()

		-- Função que percorre um dado caminho com uma origem e um destino e mostra os BoundaryEvent contidos nesse caminho
		seeBoundaryEvents(origin: FlowNode, 
					 destination: FlowNode) : Set(Event) = compute(origin, destination) -> flatten ->
										 select(oclIsKindOf(BoundaryEvent))->collect(oclAsType(BoundaryEvent)) -> asSet()

		-- Função que percorre um dado caminho com uma origem e conta o número de BoundaryEvent
		countBoundaryEventsO(origin: FlowNode) : Integer = seeBoundaryEventsO(origin) -> size()

		-- Função que percorre um dado caminho com uma origem e mostra os BoundaryEvent contidos nesse caminho
		seeBoundaryEventsO(origin: FlowNode) : Set(Event) = computeElements(origin) -> flatten
										 -> select(oclIsKindOf(BoundaryEvent))->collect(oclAsType(BoundaryEvent)) -> asSet()

		-- Função que percorre um dado caminho com uma origem e conta o número total de Artifacts (textAnnotations and groups) de um processo 
		countArtifactsO(origin: OclAny) : Integer = seeArtifactsO(origin) ->size()

		-- Função que percorre um dado caminho com uma origem e mostra todos os Artifacts de um processo
		seeArtifactsO(origin: OclAny) : Set(Artifact) = computeAll(origin) -> flatten
									 ->select(oclIsKindOf(Artifact))->collect(oclAsType(Artifact)) -> asSet()

		-- Função que percorre um dado caminho com uma origem e conta o número total de DataObjects e DataStores de um processo 
		countDataElementsO(origin: FlowNode) : Integer = countDataObjectsO(origin) + countDataStoresO(origin)

		-- Função que percorre um dado caminho com uma origem e mostra todos os DataObjects e DataStores de um processo
		seeDataElementsO(origin: FlowNode) : Set(ItemAwareElement) =  seeDataObjectsO(origin) ->union(seeDataStoresO(origin)) -> asSet()

		-- Função que percorre um dado caminho com uma origem e conta o número total de DataObjects de um processo 
		countDataObjectsO(origin: FlowNode) : Integer = seeDataObjectsO(origin) -> size()

		-- Função que percorre um dado caminho com uma origem e mostra todos os DataObjects de um processo
		seeDataObjectsO(origin: FlowNode) : Set(DataObject) = computeElements(origin) -> flatten 
									-> select(oclIsKindOf(DataObject))-> collect(oclAsType(DataObject)) -> asSet()

		-- Função que percorre um dado caminho com uma origem e conta o número total de DataStores de um processo 
		countDataStoresO(origin: FlowNode) : Integer = seeDataStoresO(origin) -> size()

		-- Função que percorre um dado caminho com uma origem e mostra todos os DataStores de um processo
		seeDataStoresO(origin: FlowNode) : Set(DataStore) = computeElements(origin) -> flatten 
									-> select(oclIsKindOf(DataStore))-> collect(oclAsType(DataStore)) -> asSet()

		-- Função que percorre um dado caminho com uma origem e conta o número total de repositório de dados (ItemAwareElement) de um processo 
		countItemAwareElementsO(origin: FlowNode) : Integer = seeItemAwareElementsO(origin) -> size()

		-- Função que percorre um dado caminho com uma origem e mostra todos os ItemAwareElements de um processo
		seeItemAwareElementsO(origin: FlowNode) : Set(ItemAwareElement) = computeElements(origin) -> flatten 
									-> select(oclIsKindOf(ItemAwareElement))-> collect(oclAsType(ItemAwareElement)) -> asSet()

		-- Função que percorre um dado caminho com uma origem e conta o número total de TexAnnotations de um processo
		countTextAnnotationsO(origin: BaseElement) : Integer = seeTextAnnotationsO(origin) -> size()

		-- Função que percorre um dado caminho com uma origem e mostra todos os TexAnnotations de um processo
		seeTextAnnotationsO(origin: BaseElement) : Set(TextAnnotation) = computeElements(origin) -> flatten 
									->select(oclIsKindOf(TextAnnotation))->collect(oclAsType(TextAnnotation)) -> asSet()

		-- Função que percorre um dado caminho com uma origem e conta o número total de Groups de um processo
		countGroupsO(origin: BaseElement) : Integer = seeGroupsO(origin) -> size()

		-- Função que percorre um dado caminho com uma origem e mostra todos os Groups de um processo
		seeGroupsO(origin: BaseElement) : Set(Group) = computePath(origin) -> flatten ->
									select(oclIsKindOf(Group))->collect(oclAsType(Group)) -> asSet()

		-- Função que percorre um dado caminho com uma origem e conta o número total de SequenceFlows de um processo
		countSequenceFlowsO(origin: OclAny) : Integer = seeSequenceFlowsO(origin) -> size()

		-- Função que percorre um dado caminho com uma origem e mostra todos os SequenceFlows de um processo
		seeSequenceFlowsO(origin: OclAny) : Set(FlowElement) = computePath(origin) -> flatten ->
										select(oclIsKindOf(SequenceFlow))-> collect(oclAsType(SequenceFlow)) -> asSet()

		-- Função que percorre um dado caminho com uma origem e conta o número total de MessageFlows de um processo
		countMessageFlowsO(origin: OclAny) : Integer = seeMessageFlowsO(origin) -> size()

		-- Função que percorre um dado caminho com uma origem e mostra todos os MessageFlows de um processo
		seeMessageFlowsO(origin: OclAny) : Set(MessageFlow) = computePath(origin) -> flatten ->
									select(oclIsKindOf(MessageFlow))-> collect(oclAsType(MessageFlow)) -> asSet()

		-- Função que percorre um dado caminho com uma origem e conta o número total de Associations de um processo (A associação não é um connector)
		countAssociationsO(origin: OclAny) : Integer = seeAssociationsO(origin) -> size()

		-- Função que percorre um dado caminho com uma origem e mostra todos os Associations de um processo
		seeAssociationsO(origin: OclAny) : Set(Association) = computePath(origin) -> flatten ->
										select(oclIsKindOf(Association))-> collect(oclAsType(Association)) -> asSet()

		-- Função que percorre um dado caminho com uma origem e conta o número total de DataAssociations de um processo (DataAssociation não é um connector)
		countDataAssociationsO(origin: OclAny) : Integer = seeDataAssociationsO(origin) -> size()

		-- Função que percorre um dado caminho com uma origem e mostra todos os DataAssociations de um processo
		seeDataAssociationsO(origin: OclAny) : Set(DataAssociation) = computePath(origin) -> flatten ->
										select(oclIsKindOf(DataAssociation))-> collect(oclAsType(DataAssociation)) -> asSet()

		-- Função que percorre um dado caminho com uma origem e conta o número total de Connectores (SequenceFlows, MessageFlows e Associations) de um processo
		countConnectors(origin: OclAny) : Integer = self.countSequenceFlowsO(origin) + self.countMessageFlowsO(origin)
																	 + self.countAssociationsO(origin)  + self.countDataAssociationsO(origin)

-- ************************************************************************************************************************
		-- mostra todos os flowElements (e.g. Activity, Event, Gateway, SequenceFlow) de um container (e.g. Process, SubProcess)
		bpmnFlowElements(): Set(FlowElement) = self.flowElements->asSet()

		-- mostra todos as tasks de um container (e.g. Process, SubProcess)
		bpmnTaskElements(): Set(Task) = self.flowElements
													->select(oclIsKindOf(Task))
													->collect(oclAsType(Task))->asSet()

		-- mostra todos os events de um container (e.g. Process, SubProcess)
		bpmnEventElements(): Set(Event) = self.flowElements
													->select(oclIsKindOf(Event))
													->collect(oclAsType(Event))->asSet()

		-- mostra todos os flowNodes (e.g. Activity, Event, Gateway) de um container (e.g. Process, SubProcess)
		bpmnFlowNodes(): Set(FlowNode) = self.flowElements
													->reject(not oclIsKindOf(FlowNode))
													->collect(oclAsType(FlowNode))->asSet()

		-- mostra todos os Artifacts (e.g. Group, TextAnnotation) de um container (e.g. Process, SubProcess)
		bpmnArtifactElements(): Set(Artifact) = self.flowElements->collect(artifacts())->asSet()

		-- mostra, se existir, os participantes (pools) associados ao corrente container (Process)
		currentParticipant(): Set(Participant) = 
								if self.oclIsTypeOf(Process) then
									self.oclAsType(Process).participant->asSet()
								else
									oclEmpty(Set(Participant))
								endif

		-- mostra todos as associations com Artifacts de um container (e.g. Process, SubProcess)
		bpmnAssociations(): Set(Association) = self.flowElements->collect(associations())->asSet()

		-- mostra todos os itemAwareElements (e.g. DataObject, DataStore, DataStoreRef, DataObjectRef) de um container (e.g. Process, SubProcess)
		bpmnItemAwareElements(): Set(OclAny) = self.flowElements
													->select(oclIsKindOf(ItemAwareElement))
													->union(self.bpmnDataElements())->asSet()

		-- mostra todos os data elements (e.g. DataObject, DataStore, DataStoreRef, DataObjectRef) de um container (e.g. Process, SubProcess)
		bpmnDataElements(): Set(ItemAwareElement) = self.flowElements
													->select(oclIsKindOf(Activity))
													->collect(oclAsType(Activity).dataElements())->asSet()

		-- mostra todos os connectores com data elements (e.g. DataObject, DataStore, DataStoreRef, DataObjectRef) de um container (e.g. Process, SubProcess)
		bpmnDataAssociations(): Set(DataAssociation) = self.flowElements
													->select(oclIsKindOf(Activity))
													->collect(oclAsType(Activity).dataAssociations())->asSet()

		-- mostra todos os connectores com interactionNodes (e.g. Task, Event, ConversationNode) de um container (e.g. Process, SubProcess)
		bpmnMessageFlows(): Set(MessageFlow) = oclEmpty(Set(InteractionNode))
													->union(self.currentParticipant())
													->union(bpmnTaskElements())
													->union(bpmnEventElements())
													->collect(oclAsType(InteractionNode).messageFlows())->asSet()

		-- mostra todos os containers (e.g. SubProcess) existentes no corrente container
		bpmnContainers() : Set(FlowElementsContainer) = self.flowElements->
													select(oclIsKindOf(SubProcess))->collect(oclAsType(SubProcess)) -> asSet()

		-- retorna todos os elementos existentes no corrente container
		bpmnElements() : Set(BaseElement) = self.bpmnFlowElements()
																				->union(self.bpmnMessageFlows())
																				->union(self.bpmnAssociations())
																				->union(self.bpmnDataAssociations())
																				->union(self.bpmnArtifactElements())
																				->union(self.bpmnDataElements()) -> asSet()

		-- retorna todos os flowNodes e data elements existentes no corrente container
		bpmnContainerContentFlowNodesDataElements() : Set(BaseElement) = self.bpmnFlowNodes()
																											->union(self.bpmnDataElements()) -> asSet()

		-- conta o número de elementos de um Container
		countBpmnElements(): Integer = bpmnElements() ->size()

		-- mostra todos os elementos de um Container e respectivos subcontainers
		bpmnAllElements(container : FlowElementsContainer): Set(Set(OclAny)) = 
			visitContainerContentAll(container, 
				 oclEmpty(Set(Set(OclAny)))->including(container.bpmnElements()->asSet()))

		visitContainerContentAll ( x: FlowElementsContainer, 
					allElementsContainers: Set(Set(OclAny))) : Set(Set(OclAny)) =

				let containers: Set(FlowElementsContainer) = x.bpmnContainers()->asSet()
				in
					if containers->isEmpty()  then
						allElementsContainers
					else
						containers->iterate(elem: FlowElementsContainer; acc: Set(Set(OclAny)) = allElementsContainers | 
								visitContainerContentAll(elem,  acc->including(elem.bpmnElements()->asSet())))
					endif

		-- mostra todos os flowNodes e data elements de um Container e respectivos subcontainers
		bpmnFlowNodesDataElements(container : FlowElementsContainer): Set(Set(OclAny)) = 
			visitContainerFlowNodesDataElements(container, 
				 oclEmpty(Set(Set(OclAny)))->including(container.bpmnContainerContentFlowNodesDataElements()->asSet()))

		visitContainerFlowNodesDataElements ( x: FlowElementsContainer, 
					allElementsContainers: Set(Set(OclAny))) : Set(Set(OclAny)) =

				let containers: Set(FlowElementsContainer) = x.bpmnContainers()->asSet()
				in
					if containers->isEmpty()  then
						allElementsContainers
					else
						containers->iterate(elem: FlowElementsContainer; acc: Set(Set(OclAny)) = allElementsContainers | 
								visitContainerFlowNodesDataElements(elem,  acc->including(elem.bpmnContainerContentFlowNodesDataElements()->asSet())))
					endif
		---------------------------- Metricas para calcular o Tamanho de um Container ------------------------------------------------------
		-- Mostra todas as lanesSets de um container
		totalContainerLaneSets(): Set(LaneSet) = self.laneSets->select(oclIsKindOf(LaneSet))->
												collect(oclAsType(LaneSet)) -> asSet()

		-- Número total de lanesSets de um container
		totalNumberLaneSets(): Integer = self.totalContainerLaneSets() -> size()

		-- Número total de lanes de um container
		totalNumberContainerLanes(): Integer = self.totalContainerLanes() -> size()

		-- Mostra todas as lanes de um container
		totalContainerLanes(): Set(Lane) = self.laneSets.lanes->select(oclIsKindOf(Lane))->
												collect(oclAsType(Lane)) -> asSet()

		-- Número total de flowNodes (gateways, activities e events) de um container
		totalNumberContainerFlowNodes(): Integer = self.bpmnElements()->select(oclIsKindOf(FlowNode))->size()

		-- Mostra todos os flowObjects de um container
		totalContainerFlowNodes(): Set(FlowNode) = self.bpmnElements()->select(oclIsKindOf(FlowNode))->
												collect(oclAsType(FlowNode)) -> asSet()

		-- Número total de actividades (subcontainers + tasks) de um container 
		totalNumberContainerActivities(): Integer = self.bpmnElements()->select(oclIsKindOf(Activity))->size()

		-- Mostra todas as actividades de um container
		totalContainerActivities(): Set(Activity) = self.bpmnElements()->select(oclIsKindOf(Activity))->
												collect(oclAsType(Activity)) -> asSet()

		-- Mostra todas as actividades de um container
		totalContainerActivitiesNotForCompensation(): Set(Activity) = self.totalContainerActivities()
												->reject(oclIsKindOf(Activity) and (oclAsType(Activity).isForCompensation = true))
												->reject(oclIsKindOf(Activity) and (oclAsType(SubProcess).triggeredByEvent = true))
												->collect(oclAsType(Activity)) -> asSet()

		-- Número total de subcontainers de um container 
		totalNumberContainerSubProcesses(): Integer = self.bpmnElements()->select(oclIsKindOf(SubProcess))->size()

		-- Mostra todos os subcontainers de um container
		totalContainerSubProcesses(): Set(SubProcess) = self.bpmnElements()->select(oclIsKindOf(SubProcess))->
												collect(oclAsType(SubProcess)) -> asSet()

		-- Número total de tasks de um container 
		totalNumberContainerTasks(): Integer = self.bpmnElements()->select(oclIsKindOf(Task))->size()

		-- Mostra todas as tasks de um container
		totalContainerTasks(): Set(Task) = self.bpmnElements()->select(oclIsKindOf(Task))->
												collect(oclAsType(Task)) -> asSet()

		-- conta o número de gateways do corrente container
		totalNumberContainerGateways() : Integer = self.totalContainerGateways() -> size()

		-- mostra as gateways contidas no corrente container
		totalContainerGateways() : Set(Gateway) = self.bpmnElements() -> 
										select(oclIsKindOf(Gateway))->collect(oclAsType(Gateway)) -> asSet()

		-- conta o número total de EventBasedGateways do corrente container
		totalNumberContainerEventBasedGateways() : Integer = self.totalContainerEventBasedGateways() -> size()

		-- mostra todos as EventBasedGateways do corrente container
		totalContainerEventBasedGateways() : Set(EventBasedGateway) = self.bpmnElements() -> 
										select(oclIsKindOf(EventBasedGateway))->collect(oclAsType(EventBasedGateway)) -> asSet()

		-- conta o número total de ExclusiveGateways do corrente container
		totalNumberContainerExclusiveGateways() : Integer = self.totalContainerExclusiveGateways() -> size()

		-- mostra todos as ExclusiveGateways do corrente container
		totalContainerExclusiveGateways() : Set(ExclusiveGateway) = self.bpmnElements() -> 
										select(oclIsKindOf(ExclusiveGateway))->collect(oclAsType(ExclusiveGateway)) -> asSet()

		-- conta o número total de InclusiveGateways do corrente container
		totalNumberContainerInclusiveGateways() : Integer = self.totalContainerInclusiveGateways() -> size()

		-- mostra todos as InclusiveGateways do corrente container
		totalContainerInclusiveGateways() : Set(InclusiveGateway) = self.bpmnElements() -> 
										select(oclIsKindOf(InclusiveGateway))->collect(oclAsType(InclusiveGateway)) -> asSet()

		-- conta o número total de ParallelGateways do corrente container
		totalNumberContainerParallelGateways() : Integer = self.totalContainerParallelGateways() -> size()

		-- mostra todos as ParallelGateways do corrente container
		totalContainerParallelGateways() : Set(ParallelGateway) = self.bpmnElements() -> 
										select(oclIsKindOf(ParallelGateway))->collect(oclAsType(ParallelGateway)) -> asSet()

		-- conta o número total de ComplexGateways do corrente container
		totalNumberContainerComplexGateways() : Integer = self.totalContainerComplexGateways() -> size()

		-- mostra todos as ComplexGateways do corrente container
		totalContainerComplexGateways() : Set(ComplexGateway) = self.bpmnElements() -> 
										select(oclIsKindOf(ComplexGateway))->collect(oclAsType(ComplexGateway)) -> asSet()

		-- Número total de eventos existentes no container
		totalNumberContainerEvents() : Integer = self.totalContainerEvents()->size()

		-- mostra os eventos existentes no container
		totalContainerEvents() : Set(Event) = self.bpmnElements()
												->select(oclIsKindOf(Event))
												->collect(oclAsType(Event)) -> asSet()

		-- Número total de ThrowEvents existentes no container
		totalNumberContainerThrowEvents() : Integer = self.totalContainerThrowEvents()->size()

		-- mostra os ThrowEvent existentes no container
		totalContainerThrowEvents() : Set(ThrowEvent) = self.bpmnElements()
												->select(oclIsKindOf(ThrowEvent))
												->collect(oclAsType(ThrowEvent)) -> asSet()

		-- Número total de EndEvents existentes no container
		totalNumberContainerEndEvents() : Integer = self.totalContainerEndEvents()->size()

		-- mostra os EndEvent existentes no container
		totalContainerEndEvents() : Set(EndEvent) = self.bpmnElements()
												->select(oclIsKindOf(EndEvent))
												->collect(oclAsType(EndEvent)) -> asSet()

		-- Número total de IntermediateThrowEvents existentes no container
		totalNumberIntermediateThrowEvents() : Integer = self.totalContainerIntermediateThrowEvents()->size()

		-- mostra os IntermediateThrowEvent existentes no container
		totalContainerIntermediateThrowEvents() : Set(IntermediateThrowEvent) = self.bpmnElements()
												->select(oclIsKindOf(IntermediateThrowEvent))
												->collect(oclAsType(IntermediateThrowEvent)) -> asSet()

		-- Número total de ImplicitThrowEvents existentes no container
		totalNumberContainerImplicitThrowEvents() : Integer = self.totalContainerImplicitThrowEvents()->size()

		-- mostra os ImplicitThrowEvent existentes no container
		totalContainerImplicitThrowEvents() : Set(ImplicitThrowEvent) = self.bpmnElements()
												->select(oclIsKindOf(ImplicitThrowEvent))
												->collect(oclAsType(ImplicitThrowEvent)) -> asSet()

		-- Número total de CatchEvents existentes no container
		totalNumberContainerCatchEvents() : Integer = self.totalContainerCatchEvents()->size()

		-- mostra os CatchEvent existentes no container
		totalContainerCatchEvents() : Set(CatchEvent) = self.bpmnElements()
												->select(oclIsKindOf(CatchEvent))
												->collect(oclAsType(CatchEvent)) -> asSet()

		-- Número total de StartEvents existentes no container
		totalNumberContainerStartEvents() : Integer = self.totalContainerStartEvents()->size()

		-- mostra os StartEvent existentes no container
		totalContainerStartEvents() : Set(StartEvent) = self.bpmnElements()
												->select(oclIsKindOf(StartEvent))
												->collect(oclAsType(StartEvent)) -> asSet()

		-- Número total de IntermediateCatchEvents existentes no container
		totalNumberContainerIntermediateCatchEvents() : Integer = self.totalContainerIntermediateCatchEvents()->size()

		-- mostra os IntermediateCatchEvent existentes no container
		totalContainerIntermediateCatchEvents() : Set(IntermediateCatchEvent) = self.bpmnElements()
												->select(oclIsKindOf(IntermediateCatchEvent))
												->collect(oclAsType(IntermediateCatchEvent)) -> asSet()

		-- Número total de BoundaryEvents existentes no container
		totalNumberContainerBoundaryEvents() : Integer = self.totalContainerBoundaryEvents()->size()

		-- mostra os BoundaryEvent existentes no container
		totalContainerBoundaryEvents() : Set(BoundaryEvent) = self.bpmnElements()
												->select(oclIsKindOf(BoundaryEvent))
												->collect(oclAsType(BoundaryEvent)) -> asSet()

		-- Número total de Artifacts (textAnnotations and groups) de um container 
		totalNumberContainerArtifacts(): Integer = self.bpmnElements()->select(oclIsKindOf(Artifact))->size()

		-- Mostra todos os Artifacts de um container
		totalContainerArtifacts(): Set(Artifact) = self.bpmnElements()->select(oclIsKindOf(Artifact))->
												collect(oclAsType(Artifact)) -> asSet()

		-- Número total de TexAnnotations de um container
		totalNumberContainerTextAnnotations(): Integer = self.bpmnElements()->select(oclIsKindOf(TextAnnotation))->size()

		-- Mostra todos os TexAnnotations de um container
		totalContainerTextAnnotations(): Set(TextAnnotation) = self.bpmnElements()->select(oclIsKindOf(TextAnnotation))->
												collect(oclAsType(TextAnnotation)) -> asSet()

		-- Número total de Groups de um container
		totalNumberContainerGroups(): Integer = self.bpmnElements()->select(oclIsKindOf(Group))->size()

		-- Mostra todos os Groups de um container
		totalContainerGroups(): Set(Group) = self.bpmnElements()->select(oclIsKindOf(Group))->
												collect(oclAsType(Group)) -> asSet()

		-- Número total de DataElements de um container 
		totalNumberContainerDataElements(): Integer = self.bpmnElements()->select(oclIsKindOf(ItemAwareElement))->size()

		-- Mostra todos os DataElements de um container
		totalContainerDataElements(): Set(ItemAwareElement) = self.bpmnElements()->select(oclIsKindOf(ItemAwareElement))->
												collect(oclAsType(ItemAwareElement)) -> asSet()

		-- Número total de SequenceFlows de um container
		totalNumberContainerSequenceFlows(): Integer = self.bpmnElements()->select(oclIsKindOf(SequenceFlow))->size()

		-- Mostra todos os SequenceFlows de um container
		totalContainerSequenceFlows(): Set(SequenceFlow) = self.bpmnElements()->select(oclIsKindOf(SequenceFlow))->
												collect(oclAsType(SequenceFlow)) -> asSet()

		-- Número total de MessageFlows de um container
		totalNumberContainerMessageFlows(): Integer = self.bpmnElements()->select(oclIsKindOf(MessageFlow))->size()

		-- Mostra todos os MessageFlows de um container
		totalContainerMessageFlows(): Set(MessageFlow) = self.bpmnElements()->select(oclIsKindOf(MessageFlow))->
												collect(oclAsType(MessageFlow)) -> asSet()

		-- Número total de Associations de um container (A associação não é um connector)
		totalNumberContainerAssociations(): Integer = self.bpmnElements()->select(oclIsKindOf(Association))->size()

		-- Mostra todos os Associations de um container
		totalContainerAssociations(): Set(Association) = self.bpmnElements()->select(oclIsKindOf(Association))->
												collect(oclAsType(Association)) -> asSet()

		-- Número total de dataAssociations de um container
		totalNumberContainerDataAssociations(): Integer = self.bpmnElements()->select(oclIsKindOf(DataAssociation))->size()

		-- Mostra todos os dataAssociations de um container
		totalContainerDataAssociations(): Set(DataAssociation) = self.bpmnElements()->select(oclIsKindOf(DataAssociation))->
												collect(oclAsType(DataAssociation)) -> asSet()

		-- Número total de Connectores (SequenceFlows, MessageFlows, Associations e DataAssociations) de um container
		totalNumberContainerConnectors(): Integer = self.totalNumberContainerSequenceFlows() + self.totalNumberContainerMessageFlows()
												+ self.totalNumberContainerAssociations() + totalNumberContainerDataAssociations()


		-- Número total de sequenceFlows de gateways de um container 
		totalNumberContainerGates(): Integer = self.bpmnElements()->select(oclIsKindOf(Gateway)).oclAsType(Gateway)->asSet->
																 collect(numberInputSequenceFlows() + numberOutputSequenceFlows())->sum()

		-- Mostra todos sequenceFlows de gateways de um container
		totalContainerGates(): Set(SequenceFlow) = self.totalContainerInputGates()
													->union(self.totalContainerOutputGates())-> asSet()

		-- Número total de sequenceFlows de input gateways de um container 
		totalNumberContainerInputGates(): Integer = self.bpmnElements()->select(oclIsKindOf(Gateway)).oclAsType(Gateway)->asSet->
																 collect(numberInputSequenceFlows())->sum()

		-- Mostra todos as sequenceFlows de input de gateways de um container
		totalContainerInputGates(): Set(SequenceFlow) = self.bpmnElements()->select(oclIsKindOf(Gateway))->
												collect(oclAsType(Gateway)).inputSequenceFlows() -> asSet()

		-- Número total de sequenceFlows de output gateways de um container
		totalNumberContainerOutputGates(): Integer = self.bpmnElements()->select(oclIsKindOf(Gateway)).oclAsType(Gateway)->asSet->
																 collect(numberOutputSequenceFlows())->sum()
																 
		-- Mostra todos as sequenceFlows de output de gateways de um container
		totalContainerOutputGates(): Set(SequenceFlow) = self.bpmnElements()->select(oclIsKindOf(Gateway))->
												collect(oclAsType(Gateway)).outputSequenceFlows() -> asSet()
		

		------------------------------ Metricas para calcular a complexidade do Container -----------------------------------------------
		---------------------------------------------- Metrica CFC ---------------------------------------------------------------------
		-- Métrica CFC (Control Flow Complexity) - calcula a complexidade de um container, adicionando os XORs, ORs e ANDs do container
												 -- só conta as gateways split (têm uma entrada e várias saídas)

		complexityProcessCFC (): Integer = self.totalContainerGateways()->
												select(isSplit())->collect(numberOutputSequenceFlows())->sum()
										
		---------------------------------------------- Metrica CFC com origem ------------------------------------------------------------
		-- Métrica CFC (Control Flow Complexity) - calcula a complexidade de um container, adicionando os XORs, ORs e ANDs dos processos
		cFC (origin: FlowNode): Integer  = computeAll(origin) -> flatten 
												-> select(oclIsKindOf(Gateway)).oclAsType(Gateway)->asSet->
														 select(isSplit())->collect(numberOutputSequenceFlows())->sum()

		----------------------------------------------  Fim da Metrica CFC --------------------------------------------------------------

		---------------------------------------------------- Metrica HPC ---------------------------------------------------------------
		-- Métrica HPC (Halstead-based Process Complexity) - calcula a complexidade de um container, estimando o comprimento, 
		-- o volume e a dificuldade do container
		-- Definição das variávéis n1, n2, N1 e N2

		-- n1 = número de actividades, slipts e joins únicos

		existActivities(): Integer = if totalNumberContainerActivities() >= 1 then 1
						else 0
						endif

		existSplits(): Integer = if totalNumberContainerOutputGates() > 1 then 1
						else 0
						endif

		existJoins(): Integer = if totalNumberContainerInputGates() > 1 then 1
						else 0
						endif
						 
		n1(): Integer = existActivities() + existSplits() + existJoins()
		
		-- n2 = número de variáveis de dados únicas (dataobject) que são manipuladas pelos containers e suas actividades

		existDataElements(): Integer = if totalNumberContainerDataElements() >= 1 then 1
						else 0
						endif

		existTextAnnotations(): Integer = if totalNumberContainerTextAnnotations() > 1 then 1
						else 0
						endif

		n2(): Integer = existDataElements() + existTextAnnotations()

		-- N1 = número total de actividades, slipts e joins de um container
		N1(): Integer = totalNumberContainerActivities() + totalNumberContainerGateways()	
		-- N2 = número total de variáveis de dados de um container
		N2(): Integer = totalNumberContainerDataElements() + totalNumberContainerTextAnnotations() 
		-- Comprimento do container: N=n1*log2(n1) + n2*log2(n2)
		length(): Real = n1() * logarithm(2, n1()) + n2() * logarithm(2, n2())

		-- Volume do container: V=(N1 + N2)*log2(n1+n2)
		volume(): Real = (N1() + N2()) * logarithm(2, n1()+n2())

		-- Dificuldade do container: D=(n1/2)*(N2/n2)
		difficulty(): Real = if (n2() = 0) then
								n1()/2
							 else
								(n1()/2)*(N2()/n2())
							 endif
		---------------------------------------------------- Metrica HPC com origem ---------------------------------------------------------------
		-- Métrica HPC (Halstead-based Process Complexity) - calcula a complexidade de um processo, estimando o comprimento, 
		-- o volume e a dificuldade do processo

		-- Definição das variávéis n1_, n2_, N1_ e N2_

		-- n1_ = número de actividades, slipts e joins únicos

		haveActivities(origin: FlowNode): Integer = if countActivitiesO(origin) >= 1 then 1 else 0 endif

		haveSplits(origin: FlowNode): Integer = if countOutputGatesO(origin) > 1 then 1 else 0 endif

		haveJoins(origin: FlowNode): Integer = if countInputGatesO(origin) > 1 then 1 else 0 endif
						 
		n1_(origin: FlowNode): Integer = haveActivities(origin) + haveSplits(origin) + haveJoins(origin)
		

		-- n2_ = número de variáveis de dados únicas (dataobject/datastore) que são manipuladas pelos processos e suas actividades

		haveDataElements(origin: FlowNode): Integer = if countItemAwareElementsO(origin) >= 1 then 1 else 0 endif

		haveTextAnnotations(origin: FlowNode): Integer = if countTextAnnotationsO(origin) > 1 then 1 else 0 endif

		n2_(origin: FlowNode): Integer = haveDataElements(origin) + haveTextAnnotations(origin)

		-- N1_ = número total de actividades, slipts e joins de um processo
		N1_(origin: FlowNode): Integer = countActivitiesO(origin) + countGatewaysO(origin)	
		-- N2_ = número total de variáveis de dados de um processo
		N2_(origin: FlowNode): Integer = countItemAwareElementsO(origin) + countTextAnnotationsO(origin) 
		-- Comprimento do processo: N=n1*log2(n1) + n2*log2(n2)
		length_(origin: FlowNode): Real = n1_(origin) * logarithm(2, n1_(origin)) + n2_(origin) * logarithm(2, n2_(origin))

		-- Volume do processo: V=(N1 + N2)*log2(n1+n2)
		volume_(origin: FlowNode): Real = (N1_(origin) + N2_(origin)) * logarithm(2, n1_(origin)+n2_(origin))

		-- Dificuldade do processo: D=(n1/2)*(N2/n2)
		difficulty_(origin: FlowNode): Real = if (n2_(origin) = 0) then
								n1_(origin)/2
							 else
								(n1_(origin)/2)*(N2_(origin)/n2_(origin))
							 endif

		---------------------------------------------------- Fim da Metrica HPC ---------------------------------------------------------------
		---------------------------------------------------- Metrica CNC ---------------------------------------------------------------

		-- Métrica CNC (Coefficient of Network Complexity) - calcula a complexidade de um container, dividindo o número de arcos 
		-- pelo número de nós, ou seja, nós = (actividades, eventos e gateways(joins e splits)) do container

		-- Métrica CNC (Coefficient of Network Complexity) = total de Sequence Connectors / total de FlowNodes
		complexityProcessCNC (): Real = totalNumberContainerSequenceFlows() / totalNumberContainerFlowNodes()

		-- Métrica CNC (Coefficient of Network Complexity) = total de Sequence Connectors / total de FlowNodes
		complexityProcessCNCO (origin: FlowNode) : Real = countSequenceFlowsO(origin) / (countFlowNodesO(origin) - countGatewaysO(origin))

		---------------------------------------------------- Metrica CNC ---------------------------------------------------------------
		------------------------------------------ Fim Metricas para calcular a complexidade do Container -------------------------------------------------------

		------------------------------------ Metrica para calcular a Estrutura do Processo ---------------------------------------------	

		-- Métrica Nesting depth - Definida a estrutura do processo, quanto maior for o valor do Nesting depth mais complexo é o modelo
		-- A Métrica Nesting depth de um elemento implica o número de decisões no fluxo de controlo que são necessárias para alcançar esse elemento

		-- A Métrica Nesting depth deve percorrer um dado caminho com um inicio e um destino e conta o número de gateways
		nestingDepth(origin: FlowNode, destination: FlowNode) : Integer = 
																				compute(origin, destination) -> flatten->
																					select(oclIsKindOf(Gateway))->collect(oclAsType(Gateway))->size()

		-- A Métrica Complexidade BPM auxiliar que percorre um dado caminho com uma origem e um destino e conta o número de sequenceFlows de output
		cfcAux(origin: FlowNode, destination: FlowNode) : Integer = 
									compute(origin, destination) ->flatten->
									select(oclIsKindOf(Gateway))->collect(oclAsType(Gateway).numberOutputSequenceFlows())->sum()
														 					 													
		--Métrica Complexidade BPM = Nesting depth + CFC
		complexityBPM(origin: FlowNode, destination: FlowNode) : Integer = 
			nestingDepth(origin, destination) +  cfcAux(origin, destination)

		-- A Métrica Nesting depth deve percorrer um dado caminho com um inicio e contar o número de gateways
		nestingDepthO(origin: FlowNode) : Integer = computeAll(origin) -> flatten->
										 select(oclIsKindOf(Gateway))->collect(oclAsType(Gateway))->size()
																																		

		-- A Métrica Complexidade BPM auxiliar que percorre um dado caminho com uma origem e conta o número de gates de output
		cfcAuxO(origin: FlowNode) : Integer = computeAll(origin) ->flatten->
										select(oclIsKindOf(Gateway))->collect(oclAsType(Gateway).numberOutputSequenceFlows())->sum()

														 					 													
		--Métrica Complexidade BPM = Nesting depth + CFC
		complexityBPMO(origin: FlowNode) : Integer = nestingDepthO(origin) + cfcAuxO(origin)

		---------------------------------------- Fim da Metrica para calcular a Estrutura do Processo -------------------------------------

		---------------------------------- Metrica para calcular a modularização do Processo ---------------------------------------------

		-- Métrica HKM (Henry and Kafura Metric) - Define a boa ou má modularização de um processo através do size e dos fluxos de entrada e de saída.
		-- Métrica HKM = número total de flowNodes (actividades, eventos e gateways) x (starts (fan-in) x ends(fan-out))^2

		-- Métrica HKM = número total de actividades (tasks e subprocessos) x (nº de startevents (fan-in) x nº de endevents (fan-out))^2
		modularizationProcessHKM(): Real = totalNumberContainerActivities() * power((totalNumberContainerStartEvents() * totalNumberContainerEndEvents()), 2) 

		-- Métrica HKM = número total de actividades (tasks e subprocessos) x (nº de startevents (fan-in) x nº de endevents (fan-out))^2
		modularizationProcessHKMO(origin: FlowNode): Real = countActivitiesO(origin) * power((countStartEventsO(origin) * countEndEventsO(origin)), 2) 

		-------------------------  Fim da Metrica para calcular a  Modularização do Processo ---------------------------------------------	

 end --FlowElementsContainer

 abstract class FlowNode < FlowElement
operations
	-- Returns the outgoing SequenceFlows from the current FlowNode
	outputSequenceFlows(): Set(SequenceFlow) = self.outgoing_a

	-- Returns true if the current FlowNode has outgoing SequenceFlows
	hasOutputSequenceFlows(): Boolean = self.outputSequenceFlows()->notEmpty()

	-- Returns true if the current FlowNode does not have outgoing SequenceFlows
	withoutOutputSequenceFlows(): Boolean = self.outputSequenceFlows()->isEmpty()

	-- Returns the incoming SequenceFlows to the current FlowNode
	inputSequenceFlows(): Set(SequenceFlow) = self.incoming_a

	-- Returns true if the current FlowNode has incoming SequenceFlows
	hasInputSequenceFlows(): Boolean =  self.inputSequenceFlows()->notEmpty()

	-- Returns true if the current FlowNode does not have incoming SequenceFlows
	withoutInputSequenceFlows(): Boolean =  self.inputSequenceFlows()->isEmpty()

	-- Returns the number of outgoing SequenceFlows from the current FlowNode
	numberOutputSequenceFlows(): Integer = self.outputSequenceFlows()->size() 

	-- Returns the number of incoming SequenceFlows to the current FlowNode
	numberInputSequenceFlows(): Integer = self.inputSequenceFlows()->size()

	-- Returns the number of connecting (incoming+outgoing) 
	-- SequenceFlows to/from the current FlowNode
	numberSequenceFlows(): Integer = 
						self.inputSequenceFlows()->size() + 
									self.outputSequenceFlows()->size()

	-- Returns the successors of a FlowNode 
	successors1_FlowNode(): Set(OclAny) = self.outgoing_a
														->union(self.associations())
														->union(successors1_FlowNode_container())->asSet()

	-- Returns the successors of the FlowNode container
	successors1_FlowNode_container(): Set(OclAny) = 
													if self.withoutOutputSequenceFlows() and 
																	self.container.oclIsKindOf(SubProcess) then
															self.container.successors1()->asSet()
													else
															oclEmpty(Set(OclAny))
													endif

	-- Returns all successors of the current FlowNode 
	successors_FlowNode(): Set(OclAny) = 
			if self.outgoing_a.targetRef->select(oclIsKindOf(SubProcess))
												->collect(oclAsType(SubProcess).successors1_inside()) 
																						-> notEmpty() then
					self.outgoing_a.targetRef->select(oclIsKindOf(SubProcess))
					->collect(oclAsType(SubProcess).successors1_inside())
						->union(self.outgoing_a.targetRef)->reject( oclIsKindOf(SubProcess) )
						->union(self.successors_Association())->asSet()
			else
						if self.withoutOutputSequenceFlows() and 
								self.container.oclIsKindOf(SubProcess) then
									self.container.oclAsType(SubProcess).outgoing_a.targetRef
									->union(self.container.oclAsType(SubProcess).dataElements())
									->union(self.successors_Association())->asSet()
						else
								self.outgoing_a.targetRef
								->union(self.successors_Association())->asSet()
						endif
			endif
	
	-- abstract implementation to implement in inherited classes of FlowNode 
	successors(): Set(OclAny) = self.successors_FlowNode()

	-- Returns only the FlowNode successors of the current FlowNode 
	successors2(): Set(OclAny) = self.outgoing_a.targetRef->asSet()

	-- Returns all precedents of the current FlowNode 
	precedents_FlowNode(): Set(FlowNode) = self.incoming_a.sourceRef->asSet()

		-- Função que devolve um nó split não-exclusivo existente, 
		-- precendente do corrente nó
			precedentNonExclusiveSplitElements() : Set(OclAny) =
				visitPrecedentSplitElement(self, 
					 oclEmpty(Set(OclAny))->including(self),
					 oclEmpty(Set(OclAny)))

		visitPrecedentSplitElement( x: OclAny, 
					visited: Set(OclAny),
					splits: Set(OclAny)) : Set(OclAny) =

				let precedents: Set(OclAny) = 
					if x.oclIsKindOf(FlowNode) then
								(x.oclAsType(FlowNode)).precedents_FlowNode()
					else
						oclEmpty(Set(OclAny))
					endif
				in
				if precedents->isEmpty() or splits->notEmpty() then
						splits
				else
						precedents->iterate(elem: OclAny; acc: Set(OclAny) = splits | 
							if (elem.oclAsType(FlowNode)).isExclusiveSplit() then 
									acc
							else
								if visited->excludes(elem) then
									visitPrecedentSplitElement(elem, visited->including(elem), 
																	if (elem.oclAsType(FlowNode)).isNotExclusiveSplit() then 
																		acc->including(elem)
																	else
																		acc
																	endif)
								else
									acc
								endif
							endif)
				endif
				
		-- Função que devolve um nó split exclusivo existente, 
		-- precendente do corrente nó
			precedentExclusiveSplitElements() : Set(OclAny) =
				visitPrecedentExclusiveSplitElement(self, 
					 oclEmpty(Set(OclAny))->including(self),
					 oclEmpty(Set(OclAny)))

		visitPrecedentExclusiveSplitElement( x: OclAny, 
					visited: Set(OclAny),
					splits: Set(OclAny)) : Set(OclAny) =

				let precedents: Set(OclAny) = 
					if x.oclIsKindOf(FlowNode) then
								(x.oclAsType(FlowNode)).precedents_FlowNode()
					else
						oclEmpty(Set(OclAny))
					endif
				in
				if precedents->isEmpty() or splits->notEmpty() then
						splits
				else
						precedents->iterate(elem: OclAny; acc: Set(OclAny) = splits | 
							if (elem.oclAsType(FlowNode)).isNotExclusiveSplit() then 
									acc
							else
								if visited->excludes(elem) then
									visitPrecedentExclusiveSplitElement(elem, visited->including(elem), 
																	if (elem.oclAsType(FlowNode)).isExclusiveSplit() then 
																		acc->including(elem)
																	else
																		acc
																	endif)
								else
									acc
								endif
							endif)
				endif
				
		-- Função que devolve true se o nó split precendente ao corrente nó for 
		-- não-exclusivo ou não existir
	precedentSplitElementIsNonExclusive() : Boolean = 
				let gateways : Set(OclAny) = oclEmpty(Set(OclAny))
				->union(collectPrecedentSplitElement(self, 
					 oclEmpty(Set(OclAny))->including(self),
					 oclEmpty(Set(OclAny)))) 
				in
				if (gateways->select(oclAsType(FlowNode).isNotExclusiveSplit())->size()>0 ) then
					 true
				else
					false
				endif

		-- Função que devolve true se o nó split precendente ao corrente nó for 
		-- exclusivo ou não existir
	precedentSplitElementIsExclusive() : Boolean = 
				let gateways : Set(OclAny) = oclEmpty(Set(OclAny))
				->union(collectPrecedentSplitElement(self, 
					 oclEmpty(Set(OclAny))->including(self),
					 oclEmpty(Set(OclAny)))) 
				in
				if (gateways->isEmpty() or 
							gateways->select(oclAsType(FlowNode).isExclusiveSplit())->size()>0 ) then
					 true
				else
					false
				endif

		collectPrecedentSplitElement( x: OclAny, 
					visited: Set(OclAny),
					splits: Set(OclAny)) : Set(OclAny) =

				let precedents: Set(OclAny) = 
					if x.oclIsKindOf(FlowNode) then
								(x.oclAsType(FlowNode)).precedents_FlowNode()->asSet()
					else
						oclEmpty(Set(OclAny))
					endif
				in
				if precedents->isEmpty() then
						splits
				else
						precedents->iterate(elem: OclAny; acc: Set(OclAny) = splits | 
								if visited->excludes(elem) then
									collectPrecedentSplitElement(elem, visited->including(elem), 
																	if (elem.oclAsType(FlowNode)).isSplit() then 
																		acc->including(elem)
																	else
																		acc
																	endif)
								else
									acc
								endif)
				endif
				

	-- Returns  the set of lanes that contains the current FlowNode 
	lanes() : Set(Lane) = self.lanes

	-- Verifica se o flowNode é Join
		isJoin(): Boolean = self.numberInputSequenceFlows() > 1 

	-- Verifica se o flowNode é Split
		isSplit() : Boolean =  self.numberOutputSequenceFlows() > 1 

	-- Verifica se o flowNode é Split não-exclusivo
		-- an event with several outgoing sequence flow
		-- an activity with several outgoing sequence flow without condition
		-- a parallel/inclusive/EventBased gateway
		-- a non interrupting boundary event 
		isNotExclusiveSplit() : Boolean =  
														(self.isSplit() and 
														(
															self.oclIsTypeOf(Event) or 
															self.oclIsTypeOf(ParallelGateway) or 
														 	self.oclIsTypeOf(InclusiveGateway) or 
														 (self.oclAsType(EventBasedGateway).eventGatewayType = 
														 						EventBasedGatewayType::Parallel) or
														 (self.oclIsKindOf(Activity) implies
														 self.oclAsType(Activity).outputSequenceFlows()->size() - 
																self.oclAsType(Activity).outputSequenceFlows().conditionExpression
																	->select(oclIsKindOf(Expression))
																	->select(oclIsTypeOf(FormalExpression))->asSet()->size() > 1)
														)) or
														(self.isNonInterruptingEvent()  and self.oclIsTypeOf(BoundaryEvent))

	-- Verifica se o flowNode é Split exclusivo
		isExclusiveSplit() : Boolean =  
														(self.isSplit() and 
														(self.oclIsTypeOf(Event) or 
														 self.oclIsTypeOf(ExclusiveGateway) or 
														 self.oclIsTypeOf(ComplexGateway) or 
														 (self.oclAsType(EventBasedGateway).eventGatewayType = 
														 						EventBasedGatewayType::Exclusive) or
														(self.oclIsKindOf(Activity) implies
														 self.oclAsType(Activity).outputSequenceFlows()->size() - 
														self.oclAsType(Activity).outputSequenceFlows().conditionExpression
															->select(oclIsKindOf(Expression))
															->select(oclIsTypeOf(FormalExpression))->asSet()->size() <= 1)))
														or
														(self.isInterruptingEvent())
	-- Se houver um join a anteceder uma gateway ou evento, é necessário 
	-- uma gateway como mediador
			isMediadorAGateway() : Boolean =
				(self.inputSequenceFlows()->size() > 1
				and 
				(self.successors()->select(oclIsKindOf(Gateway))->size() > 0 
				or 
				(self.successors()->select(oclIsKindOf(Event))->size() > 0
				and 
				self.successors()->select(oclIsKindOf(BoundaryEvent))->size() = 0)))
				implies
				self.oclIsKindOf(Gateway)

		-- Função dummy de flow node (só é utilizada pelos CatchEvent)
		isInterruptingEvent() : Boolean = false

		-- Função dummy de flow node (só é utilizada pelos CatchEvent)
		isNonInterruptingEvent() : Boolean = false

	-- if the container includes start and end events, all flow objects must have [1] (page ???):
	-- an incoming sequence flow. Exceptions are: Start Events, Boundary Events, and Compensation Activities;
	-- an outgoing sequence flow,. Exceptions are:  End Events and Compensation Activities.
    hasIncomingAndOutgoingSequenceFlow(): Boolean = true
-- TO DO

	-- Use a Default Condition when using Conditional Sequence Flow
	-- TO DO
	existsDefaultCondition(): Boolean = true


 end --FlowNode

 abstract class RootElement < BaseElement
 end --RootElement

 abstract class CatchEvent < Event
	attributes
		parallelMultiple : Boolean

operations

	-- Função que determina se o evento é interrupting
		isInterruptingEvent() : Boolean = not isNonInterruptingEvent()

	-- Função que determina se o evento é non-interrupting
		isNonInterruptingEvent() : Boolean =
			((self.oclIsTypeOf(BoundaryEvent) and 
			self.oclAsType(BoundaryEvent).cancelActivity = false) or
			(self.oclIsTypeOf(StartEvent) and 
			self.oclAsType(StartEvent).isInterrupting = false)) 
			and
			((self.eventDefinitions->select(oclIsTypeOf(MessageEventDefinition))->size() > 0) or
			 (self.eventDefinitions->select(oclIsTypeOf(ConditionalEventDefinition))->size() > 0) or
			 (self.eventDefinitions->select(oclIsTypeOf(EscalationEventDefinition))->size() > 0) or
			 (self.eventDefinitions->select(oclIsTypeOf(TimerEventDefinition))->size() > 0) or
			 (self.eventDefinitions->select(oclIsTypeOf(SignalEventDefinition))->size() > 0))

--- Cancel,Compensation,Conditional,Escalation,Error,Link,Message,Multiple,Timer,Signal,ParallelMultiple
--CancelEventDefinition, CompensateEventDefinition, ConditionalEventDefinition
--EscalationEventDefinition, ErrorEventDefinition, LinkEventDefinition
--MessageEventDefinition, TimerEventDefinition, SignalEventDefinition, TerminateEventDefinition

	-- return true if the event has no type 
		isNoneEvent() : Boolean =
			self.eventDefinitions->asSet()->size() = 0

	-- return true if the event is type Multiple
	-- With a multiple start event if one of them occurs, the process is started. 
	-- Defines two or more of Message, Error, Compensation, or Signal results (fires all triggers).
		isMultipleEvent() : Boolean =
			self.eventDefinitions->asSet()->size() > 1
			-- and (isSignalEvent() or isErrorEvent() or isMessageEvent() or isCompensateEvent()) 
	-- return true if the event is type ParallelMultiple
	-- With a parallel multiple event, all of the combined events must have occurred.
		isParallelMultipleEvent() : Boolean =
			self.parallelMultiple = true and
			self.isMultipleEvent()

	-- return true if the event is type Cancel
		isCancelEvent() : Boolean =
			self.eventDefinitions->select(oclIsTypeOf(CancelEventDefinition))->notEmpty()

	-- return true if the event is type Compensate
		isCompensateEvent() : Boolean =
			self.eventDefinitions->select(oclIsTypeOf(CompensateEventDefinition))->notEmpty()

	-- return true if the event is type Conditional
		isConditionalEvent() : Boolean =
			self.eventDefinitions->select(oclIsTypeOf(ConditionalEventDefinition))->notEmpty()

	-- return true if the event is type Escalation
		isEscalationEvent() : Boolean =
			self.eventDefinitions->select(oclIsTypeOf(EscalationEventDefinition))->notEmpty()

	-- return true if the event is type Error
		isErrorEvent() : Boolean =
			self.eventDefinitions->select(oclIsTypeOf(ErrorEventDefinition))->notEmpty()

	-- return true if the event is type Link
		isLinkEvent() : Boolean =
			self.eventDefinitions->select(oclIsTypeOf(LinkEventDefinition))->notEmpty()

	-- return true if the event is type Message
		isMessageEvent() : Boolean =
			self.eventDefinitions->select(oclIsTypeOf(MessageEventDefinition))->notEmpty()

	-- return true if the event is type Timer
		isTimerEvent() : Boolean =
			self.eventDefinitions->select(oclIsTypeOf(TimerEventDefinition))->notEmpty()

	-- return true if the event is type Signal
		isSignalEvent() : Boolean =
			self.eventDefinitions->select(oclIsTypeOf(SignalEventDefinition))->notEmpty()

	-- return true if the event is type Terminate
		isTerminateEvent() : Boolean =
			self.eventDefinitions->select(oclIsTypeOf(TerminateEventDefinition))->notEmpty()

		-- Error intermediate events cannot be used within normal sequence flows. 
		-- They can only be attached to activity boundaries. 
		isCatchingErrorAttachedToActivityBoundary() : Boolean =
			self.isErrorEvent() implies
				self.oclIsTypeOf(BoundaryEvent)

	-- A catching error reacts to thrown errors with the same label.
		catchingErrorEventNameMatchThrowEventName() : Boolean =
		(self.isErrorEvent() and self.oclAsType(BoundaryEvent).attachedToRef.oclIsTypeOf(SubProcess) 
		 and self.name.isDefined())
		implies
		self.oclAsType(BoundaryEvent).attachedToRef.oclAsType(SubProcess).totalContainerThrowEvents()
			->exists(t |(t.name.isDefined() and self.name = t.name)  and t.isErrorEvent())


	-- If there are several error intermediate events attached to a sub-process 
	-- boundary, they should be always labeled. Since an unlabeled error
	-- intermediate event always catches any type of error, it also reacts 
	-- to errors caused by labeled events. Therefore, the resulting implicit
	-- parallel flows would be difficult to understand.
		noMixNamedAndUnnamedcatchingErrorEvents() : Boolean =
		((self.isErrorEvent() and self.oclIsTypeOf(BoundaryEvent) and self.name.isDefined())
		implies
		(self.oclAsType(BoundaryEvent).attachedToRef.boundaryEventRefs
					->select(name.isUndefined())->isEmpty()))
		and 
		((self.isErrorEvent() and self.oclIsTypeOf(BoundaryEvent) and self.name.isUndefined())
		implies
		(self.oclAsType(BoundaryEvent).attachedToRef.boundaryEventRefs
					->select(name.isDefined())->isEmpty()))

	-- An escalation is caught by an escalation intermediate event attached to 
	-- the sub-process border. The intermediate event should trigger an 
	-- exception flow.
	isCatchingEscalationAttachedToActivityBoundary() : Boolean =
		self.isEscalationEvent() implies
			self.oclIsTypeOf(BoundaryEvent) 

	-- A catching escalation event reacts to thrown escalation events with the same label.
	-- If there is an unlabeled intermediate event catching escalation, it reacts to
	-- any type of escalation.	
		catchingEscalationEventNameMatchThrowEventName() : Boolean =
		(self.isEscalationEvent() and self.oclAsType(BoundaryEvent).attachedToRef.oclIsTypeOf(SubProcess) 
		 and self.name.isDefined())
		implies
		self.oclAsType(BoundaryEvent).attachedToRef.oclAsType(SubProcess).totalContainerThrowEvents()
			->exists(t |(t.name.isDefined() and self.name = t.name)  and t.isEscalationEvent())

	-- If there are several interrupting escalation intermediate events attached to a sub-process 
	-- boundary, they should be always labeled. Since an unlabeled escalation
	-- intermediate event always catches any type of escalation, it also reacts 
	-- to escalations caused by labeled events. Therefore, the resulting implicit
	-- parallel flows would be difficult to understand.
		noMixNamedAndUnnamedCatchingInterEscalationEvents() : Boolean =
		((self.isInterruptingEvent() and self.isEscalationEvent() and self.oclIsTypeOf(BoundaryEvent) 
				and self.name.isDefined())
		implies
		(self.oclAsType(BoundaryEvent).attachedToRef.boundaryEventRefs
					->select(isInterruptingEvent() and name.isUndefined())->isEmpty))
		and 
		((self.isInterruptingEvent() and self.isEscalationEvent() and self.oclIsTypeOf(BoundaryEvent) 
				and self.name.isUndefined())
		implies
		(not self.oclAsType(BoundaryEvent).attachedToRef.boundaryEventRefs
					->exists(isInterruptingEvent() and name.isDefined())))


	-- If there are several non-interrupting escalation intermediate events attached to a sub-process 
	-- boundary, they should be always labeled. Since an unlabeled escalation
	-- intermediate event always catches any type of escalation, it also reacts 
	-- to escalations caused by labeled events. Therefore, the resulting implicit
	-- parallel flows would be difficult to understand.
		noMixNamedAndUnnamedCatchingNonInterEscalationEvents() : Boolean =
		((self.isNonInterruptingEvent() and self.isEscalationEvent() and self.oclIsTypeOf(BoundaryEvent) 
				and self.name.isDefined())
		implies
		(self.oclAsType(BoundaryEvent).attachedToRef.boundaryEventRefs
					->select(isNonInterruptingEvent() and name.isUndefined())->isEmpty))
		and 
		((self.isNonInterruptingEvent() and self.isEscalationEvent() and self.oclIsTypeOf(BoundaryEvent) 
				and self.name.isUndefined())
		implies
		(not self.oclAsType(BoundaryEvent).attachedToRef.boundaryEventRefs
					->exists(isNonInterruptingEvent() and name.isDefined())))

	-- If an escalation is required to abort the entire activity, the attached 
	-- intermediate event's boundaries is an interrupting event. 
	-- In this case, the throwing escalation event in the sub-process needs to be 
	-- an end event. The throwing escalation event is caught by an escalation
	-- intermediate event with the same name, attached to the sub-process border.
		catchEscalationEventInterruptingEventHasEndEvent() : Boolean =
		(self.isEscalationEvent() and self.isInterruptingEvent()) and self.name.isDefined()
		implies
			(self.oclAsType(BoundaryEvent).attachedToRef.oclIsTypeOf(SubProcess) and
			self.oclAsType(BoundaryEvent).attachedToRef.oclAsType(SubProcess).totalContainerEndEvents()
						->one(name.isDefined() and self.name = name))
		or
		((self.isEscalationEvent() and self.isInterruptingEvent() and self.name.isUndefined())
		implies
			(self.oclAsType(BoundaryEvent).attachedToRef.oclIsTypeOf(SubProcess) and
			self.oclAsType(BoundaryEvent).attachedToRef.oclAsType(SubProcess).totalContainerEndEvents()
						->select(isEscalationEvent())->notEmpty()))

	-- Catching intermediate events of the compensation type are:
	-- boundary events attached to an activity, and they always have outgoing compensation 
	-- associations running to the compensating activity. 
	-- or
	-- start event in an event subprocess
		compensationEventIsAttachedToActivityBoundary() : Boolean =
		self.isCompensateEvent() implies
			((self.oclIsTypeOf(BoundaryEvent) and
			 self.oclAsType(BoundaryEvent).attachedToRef.isDefined() and
			 self.eventDefinitions
			 		->select(oclIsTypeOf(CompensateEventDefinition))
			 		->collect(oclAsType(CompensateEventDefinition).activityRef)->notEmpty()) 
			 or
			 (self.oclIsTypeOf(StartEvent) and self.container.oclIsTypeOf(SubProcess) 
			 	and self.container.oclAsType(SubProcess).isEventSubProcess()))

		-- return true if the event is attached to the boundary of a transaction
		isAttachedActivityTransaction() : Boolean =
		self.oclAsType(BoundaryEvent).attachedToRef.oclIsTypeOf(Transaction)

	-- In order to match throw and catch Link Events, their names must be defined. 
	isNameOfCatchLinkEventsDefined() : Boolean = 
							(self.container.totalContainerCatchEvents()
												->select(isLinkEvent())->forAll(name.isDefined()))




 end --CatchEvent

 abstract class Event < FlowNode, InteractionNode
 	operations
	-- Returns the successors of the current Event
		successors1(): Set(OclAny) = successors1_FlowNode()
												->union(successors1_InteractionNode())->asSet()

	-- Returns the flowNodes and interactionNode that are successors of the current Event
		successors(): Set(OclAny) = self.successors_FlowNode()->union(self.successors_InteractionNode())

	-- Returns the flowNodes and interactionNode that are successors of the current Event
		successors2(): Set(OclAny) = self.messageFlow.targetRef->union(self.outgoing_a.targetRef)->asSet()

	-- Test if the event has one and only one outgoing sequence flow/target flow node
		isNotSplitAndHasOneTarget() : Boolean =
		if self.oclIsTypeOf(BoundaryEvent)  then
				(not self.oclAsType(BoundaryEvent).isCompensateEvent()
				and -- it is not target to a SubProcess
				(self.outgoing_a.targetRef->select(oclIsKindOf(FlowElementsContainer))->size()=0)
				)
				implies
				(
				(self.outputSequenceFlows()->size() = 1)
				and 
				(self.outgoing_a.targetRef->select(oclIsKindOf(FlowNode))->size() = 1)
				 )
	else
		true
	endif
	


 end --Event

 abstract class EventDefinition < RootElement
 end --EventDefinition

 abstract class ThrowEvent < Event
 
 	operations
 	
-- Cancel,Compensation,Conditional,Escalation,Error,Link,Message,Multiple,Timer,Signal,ParallelMultiple
--CancelEventDefinition, CompensateEventDefinition, ConditionalEventDefinition
--EscalationEventDefinition, ErrorEventDefinition, LinkEventDefinition
--MessageEventDefinition, TimerEventDefinition, SignalEventDefinition, TerminateEventDefinition


	-- return true if the event has no type 
		isNoneEvent() : Boolean =
			self.eventDefinitions->asSet()->size() = 0


	-- return true if the event is type Multiple
	-- With a multiple start event if one of them occurs, the process is started. 
		isMultipleEvent() : Boolean =
			self.eventDefinitions->asSet()->size() > 1

	-- return true if the event is type ParallelMultiple
	-- With a parallel multiple event, all of the combined events must have occurred.
		isParallelMultipleEvent() : Boolean =
			false

	-- return true if the event is type Cancel
		isCancelEvent() : Boolean =
			self.eventDefinitions->select(oclIsTypeOf(CancelEventDefinition))->notEmpty()

	-- return true if the event is type Compensate
		isCompensateEvent() : Boolean =
			self.eventDefinitions->select(oclIsTypeOf(CompensateEventDefinition))->notEmpty()

	-- return true if the event is type Conditional
		isConditionalEvent() : Boolean =
			self.eventDefinitions->select(oclIsTypeOf(ConditionalEventDefinition))->notEmpty()

	-- return true if the event is type Escalation
		isEscalationEvent() : Boolean =
			self.eventDefinitions->select(oclIsTypeOf(EscalationEventDefinition))->notEmpty()

	-- return true if the event is type Error
		isErrorEvent() : Boolean =
			self.eventDefinitions->select(oclIsTypeOf(ErrorEventDefinition))->notEmpty()

	-- return true if the event is type Link
		isLinkEvent() : Boolean =
			self.eventDefinitions->select(oclIsTypeOf(LinkEventDefinition))->notEmpty()

	-- return true if the event is type Message
		isMessageEvent() : Boolean =
			self.eventDefinitions->select(oclIsTypeOf(MessageEventDefinition))->notEmpty()

	-- return true if the event is type Timer
		isTimerEvent() : Boolean =
			self.eventDefinitions->select(oclIsTypeOf(TimerEventDefinition))->notEmpty()

	-- return true if the event is type Signal
		isSignalEvent() : Boolean =
			self.eventDefinitions->select(oclIsTypeOf(SignalEventDefinition))->notEmpty()

	-- return true if the event is type Terminate
		isTerminateEvent() : Boolean =
			self.eventDefinitions->select(oclIsTypeOf(TerminateEventDefinition))->notEmpty()

	-- Error events can be modeled in a sub-process. 
	-- A throwing error is caught by an error intermediate event with the same name,
	-- or unnamed attached to the sub-process border.
	throwErrorHasCatchEvent() : Boolean =
		self.isErrorEvent() implies
			self.container.oclAsType(SubProcess).totalContainerBoundaryEvents()
				->one(((name.isDefined() and self.name = name) or name.isUndefined()) and isInterruptingEvent())

	-- Throwing escalation events can be modeled in a sub-process. 
	-- If an escalation is required to abort the entire activity the throwing
	-- escalation event in the sub-process needs to be an end event.
	-- An escalation is caught by an interrupting escalation intermediate event 
	-- with the same name or unnamed, attached to the sub-process border.
	isThrowingEscalationEndEventInterrupting() : Boolean =
		(self.isEscalationEvent() and self.oclIsTypeOf(EndEvent))
			 implies
		self.container.oclAsType(SubProcess).totalContainerBoundaryEvents()
				->one(((name.isDefined() and self.name = name) or name.isUndefined()) 
						and isEscalationEvent() and isInterruptingEvent())

	-- Throwing escalation events can be modeled in a sub-process. 
	-- If an escalation is required not abort the entire activity, the throwing
	-- escalation event in the sub-process needs to be an intermediate event.
	-- The escalation is caught by an escalation intermediate event with the same name
	-- or unnamed, attached to the sub-process border.
	isThrowingEscalationIntermediateEventNonInterrupting()  : Boolean =
		(self.isEscalationEvent() and self.oclIsTypeOf(IntermediateThrowEvent))
			 implies
		self.container.oclAsType(SubProcess).totalContainerBoundaryEvents()
				->one(((name.isDefined() and self.name = name) or name.isUndefined()) 
						and isEscalationEvent() and isNonInterruptingEvent())

	-- In order to match throw and catch Link Events, their names must be defined. 
	isNameOfThrowLinkEventsDefined() : Boolean = 
							(self.container.totalContainerThrowEvents()
												->select(isLinkEvent())->forAll(name.isDefined()))

	-- Throwing Signal events can be modeled in a process. 
	-- A throwing signal is caught by a signal intermediate event with the same name,
	-- or unnamed in the same process or another process of same collaboration.
	hasCatchSignalEvent()  : Boolean = 
			self.isSignalEvent() implies
			self.ownProcess().definitionalCollaborationRef.process_a
			->iterate(elem: FlowElementsContainer; acc: Set(Set(OclAny)) = oclEmpty(Set(Set(OclAny))) | 
								acc->including(elem.bpmnAllElements(elem)->flatten))->flatten 
								->select(oclIsKindOf(CatchEvent))
				->exists(((oclAsType(CatchEvent).name.isDefined() and 
						self.name = oclAsType(CatchEvent).name) or 
						oclAsType(CatchEvent).name.isUndefined()) and 
						oclAsType(CatchEvent).isSignalEvent()) 



 end --ThrowEvent

 abstract class Gateway < FlowNode
	attributes
		gatewayDirection : GatewayDirection

	operations
		-- Returns the successors of the current Gateway
		successors1(): Set(OclAny) = self.outgoing_a->union(self.associations())

		-- Verifica se a gateway é Join
		isJoin(): Boolean = self.gatewayDirection = GatewayDirection::Converging or
												self.gatewayDirection = GatewayDirection::Mixed or
												(self.gatewayDirection = GatewayDirection::Unspecified and self.numberInputSequenceFlows() > 1 ) or
												(self.gatewayDirection.isUndefined() and self.numberInputSequenceFlows() > 1 )


		-- Verifica se a gateway é Split
		isSplit() : Boolean = self.gatewayDirection = GatewayDirection::Diverging or
												self.gatewayDirection = GatewayDirection::Mixed or
												(self.gatewayDirection = GatewayDirection::Unspecified and self.numberOutputSequenceFlows() > 1 ) or
												(self.gatewayDirection.isUndefined() and self.numberOutputSequenceFlows() > 1 )

	 -- Verifica se os sequence flows a seguir a uma data Based Exclusive Gateway 
	 -- tem condições, ou em caso negativo, o sucessor é um evento intermédio ou uma 
	 -- actividade "receive" 
	 		dataBasedExclusiveGatewayHasConditions() : Boolean =
			(
		(self.oclIsKindOf(EventBasedGateway)) and 
				(self.oclAsType(EventBasedGateway).eventGatewayType = EventBasedGatewayType::Exclusive)
				) 
		implies
		(
		(self.outputSequenceFlows()->size() = 
		self.outputSequenceFlows().conditionExpression
			->select(oclIsKindOf(Expression))
			->select(oclIsTypeOf(FormalExpression))->asSet()->size())
		or
		(
		self.outputSequenceFlows()->size() = 
		(self.successors()
			->select(oclIsKindOf(IntermediateCatchEvent))
			->select(oclIsTypeOf(IntermediateCatchEvent))->asSet()->size() )
		+
		(self.successors()
			->select(oclIsKindOf(ReceiveTask))
			->select(oclIsTypeOf(ReceiveTask))->asSet()->size() )
		)
		)


	-- If an exclusive gateway is used for merging, it must be ensured that every 
	-- time only one entrance receives a token. This can be achieved by modeling 
	-- the preceding split with an exclusive gateway, too. If an exclusive gateway 
	-- is used, exactly only one sequence flow would be selected in every case. 
	-- Alternatively it can be the result of a sequence flow loop.
		hasMergingExclusiveGatewayExclusiveTokens() : Boolean =
	(self.isJoin() and self.oclIsTypeOf(ExclusiveGateway)) implies 
			((self.precedentExclusiveSplitElements()->size() > 0) or
			(self.container.computeFlowNodePath(self,self)->size() > 0) or
			(self.precedentNonExclusiveSplitElements()->select(oclAsType(Gateway).isJoin())->size() <= 1) )

 end --Gateway

--- Processing Concrete Classes 

 class ResourceAssignmentExpression
 end --ResourceAssignmentExpression

 class ResourceParameterBinding
 end --ResourceParameterBinding

 class ParticipantMultiplicity
	attributes
		minimum : Integer
		maximum : Integer
 end --ParticipantMultiplicity

 class Extension
	attributes
		mustUnderstand : Boolean
 end --Extension

 class ExtensionAttributeDefinition
	attributes
		name : String
		type : String
		isReference : Boolean
 end --ExtensionAttributeDefinition

 class ExtensionAttributeValue
 end --ExtensionAttributeValue

 class ExtensionDefinition
	attributes
		name : String
 end --ExtensionDefinition

 class InputOutputBinding
 end --InputOutputBinding

 class Escalation
	attributes
		name : String
		escalationCode : String
 end --Escalation

 class Import
	attributes
		importType : String
		location : String
		namespace : String
 end --Import

 class Element
 end --Element

 class Diagram
 end --Diagram

 class DiagramElement
 end --DiagramElement

 class Label
 end --Label

 class LabeledEdge
 end --LabeledEdge

 class LabeledShaped
 end --LabeledShaped

 class Plane
 end --Plane

 class Style
 end --Style

 class AdHocSubProcess < SubProcess
	attributes
		ordering : AdHocOrdering
		cancelRemainingInstances : Boolean
	operations
		
	-- Returns the elements successors of the current FlowNode 
	successors(): Set(OclAny) = self.successors_Activity()
	
	-- Returns the sucessors inside the current SubProcess
	successors1_inside(): Set(OclAny) = self.flowElements->select(oclIsKindOf(FlowNode)) 
																-> select(oclAsType(FlowNode).withoutInputSequenceFlows()) -> asSet()
 end --AdHocSubProcess

 class BusinessRuleTask < Task
	attributes
		implementation : String
 end --BusinessRuleTask

 class CallActivity < Activity
 operations
 
	-- A called process itself can be a normal process. It could also be performed
	-- for itself, without being called from other process.
	-- A normal sub-process cannot be called from a different process. 
	-- A called process can have several start events. Exactly one of them should 
	-- be an untyped event. At least one must be a catching start event. 
	-- A call activity can call another process. The re-use of processes is only 
	-- possible with independent processes which are included via call activities.
 	isCallable() : Boolean = 
		if self.calledElementRef.isDefined() then
				if self.calledElementRef.oclIsTypeOf(Process) then
					self.calledElementRef.oclAsType(Process).isCallable()
				else
					self.calledElementRef.oclIsKindOf(GlobalTask)
				endif
		else 
			false
		endif

 end --CallActivity

 class ComplexBehaviorDefinition < BaseElement
 end --ComplexBehaviorDefinition

 class GlobalBusinessRuleTask < GlobalTask
	attributes
		implementation : String
 end --GlobalBusinessRuleTask

 class GlobalScriptTask < GlobalTask
	attributes
		scriptLanguage : String
		script : String
 end --GlobalScriptTask

 class MultiInstanceLoopCharacteristics < LoopCharacteristics
	attributes
		isSequential : Boolean
		behavior : MultiInstanceBehavior
 end --MultiInstanceLoopCharacteristics

 class ReceiveTask < Task
	attributes
		implementation : String
		instantiate : Boolean
 end --ReceiveTask

 class ResourceRole < BaseElement
	attributes
		name : String
 end --ResourceRole

 class ScriptTask < Task
	attributes
		scriptFormat : String
		script : String
 end --ScriptTask

 class SendTask < Task
	attributes
		implementation : String
 end --SendTask

 class ServiceTask < Task
	attributes
		implementation : String
 end --ServiceTask

 class StandardLoopCharacteristics < LoopCharacteristics
	attributes
		testBefore : Boolean
 end --StandardLoopCharacteristics

 class SubProcess < FlowElementsContainer, Activity
	attributes
		triggeredByEvent : Boolean
	operations
			-- Returns the sucessors of the current SubProcess
		successors1(): Set(OclAny) = successors1_FlowNode()
																	->union(successors1_BoundaryEvent())
																	->union(self.dataOutputAssociations)
																	->union(self.dataInputAssociations)			

	-- Returns the elements successors of the current FlowNode 
	successors(): Set(OclAny) = self.successors_Activity()

	-- Returns the sucessors inside the current SubProcess
	successors1_inside(): Set(OclAny) = self.flowElements->select(oclIsKindOf(FlowNode)) 
																-> select(oclAsType(FlowNode).withoutInputSequenceFlows()) -> asSet()

	--Returns true if the current SubProcess is an embedded SubProcess
	isEmbeddedSubProcess() : Boolean =
			(self.oclIsTypeOf(SubProcess)) and
			((self.triggeredByEvent.isDefined() and (self.triggeredByEvent = false)) or 
			self.triggeredByEvent.isUndefined())

	-- Returns true if the current SubProcess is an Event SubProcess
	isEventSubProcess(): Boolean =
			(self.triggeredByEvent.isDefined() and (self.triggeredByEvent = true))

	-- Returns true if the current SubProcess is an AdHoc SubProcess
	isAdHocSubProcess(): Boolean =
			(self.oclIsTypeOf(AdHocSubProcess))

	-- Returns true if the current SubProcess is a Transaction SubProcess
	isTransactionSubProcess(): Boolean =
			(self.oclIsTypeOf(Transaction))

	-- Returns true if the current SubProcess starts compensation process
	startsACompensation(): Boolean =
			(self.totalContainerStartEvents()
							->select(isCompensateEvent())->size() > 0)

	-- Returns true if the current SubProcess is a SubProcess for Compensation
	isForCompensationSubProcess(): Boolean =
			(self.isForCompensation.isDefined() and (self.isForCompensation = true))


	-- A message flow from a collapsed Subprocess is replicated in the child-level diagram.
	-- A message flow to a collapsed Subprocess is replicated in the child level diagram.
	-- An incoming message flow in child level diagram is replicated in the parent level.
	-- An outgoing message flow in child level diagram should is replicated in the parent level.
	isMessageFlowconsistent() : Boolean = true


	-- An embedded Sub-Process can only have one type of Start Event: the
	-- None Start Event (page 241).
	hasOnlyOneNoneStartEvent() : Boolean = 
	isEmbeddedSubProcess() 
		and (bpmnFlowNodes() - self.boundaryEventRefs)->notEmpty()
		implies 
	((totalNumberContainerNoneStartEvents() = 1) and 
	(totalNumberContainerStartEvents()=1))

	-- Only one of a restricted type of start events (message, conditional, escalation,
	-- timer, signal, multiple, and parallel multiple events) are possible 
	-- within an event sub-process. 
		isStartEventAllowed() : Boolean = 
			self.oclAsType(SubProcess).isEventSubProcess() 
			implies
			self.totalContainerStartEvents()
					->select(isMessageEvent() or 
						isConditionalEvent() or 
						isEscalationEvent() or 
						isTimerEvent() or 
						isSignalEvent() or 
						isMultipleEvent() or 
						isParallelMultipleEvent())
						->size() = 
					self.totalNumberContainerStartEvents()
					and self.totalNumberContainerStartEvents() = 1


	-- A sub-process must not have more than one untyped start event. Otherwise 
	-- it is not clear where the sub-process starts after having been triggered 
	-- by the parent process.
	hasOnlyOneStartEvent() : Boolean = 
	not (self.isEmbeddedSubProcess() or  self.isEventSubProcess())
	implies
	totalNumberContainerNoneStartEvents() <= 1 and
	totalNumberContainerStartEvents() > 0

	-- An Event SubProcess must not have incoming or outgoing Sequence Flow
	hasNoIncomingOutgoingSequenceFlow() : Boolean = 
			self.isEventSubProcess() 
			implies
			hasNoIncomingAndOutgoingSequenceFlow()

	-- A reusable SubProcess has only self-contained data 
	-- TO DO
	isDataSelfContained()  : Boolean = true

	-- If a SubProcess is followed by a yes/no gateway, at least one 
	-- end event of the SubProcess should be labeled to match the gateway label.
	-- TO DO
    matchGatewayName() : Boolean = true




 end --SubProcess

 class Task < Activity --InteractionNode, ****** CHANGED revoved InteractionNode
	operations
	-- Returns the successors of the current Task
		successors1(): Set(OclAny) = successors1_FlowNode()
																	->union(successors1_InteractionNode())
																	->union(successors1_BoundaryEvent())
																	->union(self.dataOutputAssociations)
																	->union(self.dataInputAssociations)			

	-- Returns the flowNodes and interactionNode that are successors of the current Task
		successors(): Set(OclAny) = self.successors_Activity()->union(self.successors_InteractionNode())->asSet()

	-- Returns the flowNodes and interactionNode that are successors of the current Task
		successors2(): Set(OclAny) = self.messageFlow.targetRef->union(self.outgoing_a.targetRef)->asSet()

 end --Task

 class Transaction < SubProcess
	attributes
		protocol : String
		method : String
 end --Transaction

 class Association < Artifact
	attributes
		associationDirection : AssociationDirection
	operations
		-- Returns the successors of the current Association (the AssociationDirection is irrelevant)
		successors1(): Set(OclAny) = 
							oclEmpty(Set(OclAny))->including(self.sourceRef)->including(self.targetRef)

 end --Association

 class Category < RootElement
	attributes
		name : String
 end --Category

 class CategoryValue < BaseElement
	attributes
		value : String
 end --CategoryValue

 class Group < Artifact
 end --Group

 class TextAnnotation < Artifact
	attributes
		text : String
		textFormat : String
 end --TextAnnotation

 class BPMNDiagram < Diagram
 end --BPMNDiagram

 class BPMNEdge < LabeledEdge
	attributes
		messageVisibleKind : MessageVisibleKind
 end --BPMNEdge

 class BPMNLabel < Label
 end --BPMNLabel

 class BPMNLabelStyle < Style
 end --BPMNLabelStyle

 class BPMNPlane < Plane
 end --BPMNPlane

 class BPMNShape < LabeledShaped
	attributes
		isHorizontal : Boolean
		isExpanded : Boolean
		isMarkerVisible : Boolean
		isMessageVisible : Boolean
		participantBandKind : ParticipantBandKind
 end --BPMNShape

 class Choreography < Collaboration, FlowElementsContainer
 end --Choreography

 class GlobalChoreographyTask < Choreography
 end --GlobalChoreographyTask

 class CallChoreography < ChoreographyActivity
 end --CallChoreography

 class ChoreographyTask < ChoreographyActivity
 end --ChoreographyTask

 class SubChoreography < FlowElementsContainer, ChoreographyActivity
 end --SubChoreography

 class Collaboration < RootElement
	attributes
		name : String
		isClosed : Boolean

	operations
	-- Returns the successors of the current Collaboration
		successors1(): Set(OclAny) = self.participants->asSet()
		
	-- Returns the nodes that are successors of the current Collaboration
		successors(): Set(OclAny) = self.participants->asSet()
		
	-- Returns the number of processes in the Collaboration diagram
	totalNumberProcessesInCollaboration() : Integer =
		self.process_a->size() 
	
	-- Returns the number of participants in the Collaboration diagram
	totalNumberPoolsInCollaboration() : Integer =
		self.participants->size() 
	
		---------------------------- Metricas para calcular o tamanho do Modelo ------------------------------------------------------

		-- Número total de participantes (pools) na colaboração
		totalNumberCollaborationParticipants(): Integer = collaborationParticipants()-> size()

		-- participantes (pools) na colaboração
		collaborationParticipants(): Set(Participant) = self.participants->select(oclIsKindOf(Participant))->
												collect(oclAsType(Participant))->asSet()
		---------------------------- Metricas para calcular o tamanho do Modelo ------------------------------------------------------

		-- Número total de processos de um modelo 
		totalNumberModelProcesses(): Integer = self.process_a->size()

		-- Número total de swimlanes (pools + lanes) de um modelo 
		totalNumberModelSwimlanes(): Integer = self.process_a->collect(totalNumberContainerSwimlanes())->sum()

		-- Número total de pools de um modelo 
		totalNumberModelPools(): Integer = self.process_a->collect(totalNumberContainerPools())->sum()

		-- Mostra todas as pools de um modelo
		totalModelPools(): Set(Set(Participant)) =
			self.process_a->iterate(p; acc: Set(Set(Participant)) = Set{} | 
									acc->including(p.totalContainerPools()))
										
		-- Número total de lanes de um modelo
		totalNumberModelLanes(): Integer = self.process_a->collect(totalNumberContainerLanes())->sum()

		-- Mostra todas as lanes de um modelo
		totalModelLanes(): Set(Set(Lane)) = 
			self.process_a->iterate(p; acc: Set(Set(Lane)) = Set{} | 
									acc->including(p.totalContainerLanes()))

		-- Número total de FlowNodes (gateways, activities e events) de um modelo
		totalNumberModelFlowNodes(): Integer = self.process_a->collect(totalNumberContainerFlowNodes())->sum()

		-- Mostra todos os FlowNodes (gateways, activities e events) de um modelo
		totalModelFlowNodes(): Set(Set(FlowNode)) =
			self.process_a->iterate(p; acc: Set(Set(FlowNode)) = Set{} | 
									acc->including(p.totalContainerFlowNodes()))

		-- Número total de actividades (subprocessos + tasks) de um modelo 
		totalNumberModelActivities(): Integer = self.process_a->collect(totalNumberContainerActivities())->sum()

		-- Mostra todas as actividades (subprocessos + tasks) de um modelo
		totalModelActivities(): Set(Set(Activity)) = 
			self.process_a->iterate(p; acc: Set(Set(Activity)) = Set{} | 
									acc->including(p.totalContainerActivities()))
										
		-- Número total de subprocessos de um modelo 
		totalNumberModelSubProcesses(): Integer = self.process_a->collect(totalNumberContainerSubProcesses())->sum()

		-- Mostra todos os subprocessos de um modelo
		totalModelSubProcesses(): Set(Set(SubProcess)) =
			self.process_a->iterate(p; acc: Set(Set(SubProcess)) = Set{} | 
									acc->including(p.totalContainerSubProcesses()))

		-- Número total de tasks de um modelo
		totalNumberModelTasks(): Integer = self.process_a->collect(totalNumberContainerTasks())->sum()

		-- Mostra todas as tasks de um modelo
		totalModelTasks(): Set(Set(Task)) =
			self.process_a->iterate(p; acc: Set(Set(Task)) = Set{} | 
									acc->including(p.totalContainerTasks()))

		-- Número total de eventos (startevent, intermediateevent, endevent) de um modelo 
		totalNumberModelEvents(): Integer = self.process_a->collect(totalNumberContainerEvents())->sum()

		-- Mostra todos os eventos (startevent, intermediateevent, endevent) de um modelo
		totalModelEvents(): Set(Set(Event)) =
			self.process_a->iterate(p; acc: Set(Set(Event)) = Set{} | 
									acc->including(p.totalContainerEvents()))
							
		-- Número total de StartEvents de um modelo
		totalNumberModelStartEvents(): Integer = self.process_a->collect(totalNumberContainerStartEvents())->sum()

		-- Mostra todos os StartEvents de um modelo
		totalModelStartEvents(): Set(Set(StartEvent)) =
			self.process_a->iterate(p; acc: Set(Set(StartEvent)) = Set{} | 
									acc->including(p.totalContainerStartEvents()))

		-- Número total de EndEvents de um modelo 
		totalNumberModelEndEvents(): Integer = self.process_a->collect(totalNumberContainerEndEvents())->sum()

		-- Mostra todos os EndEvents de um modelo
		totalModelEndEvents(): Set(Set(EndEvent)) =
			self.process_a->iterate(p; acc: Set(Set(EndEvent)) = Set{} | 
									acc->including(p.totalContainerEndEvents()))

		-- Número total de ThrowEvents de um modelo
		totalNumberModelThrowEvents(): Integer = self.process_a->collect(totalNumberContainerThrowEvents())->sum()

		-- Mostra todos os ThrowEvents de um modelo
		totalModelThrowEvents(): Set(Set(ThrowEvent)) =
			self.process_a->iterate(p; acc: Set(Set(ThrowEvent)) = Set{} | 
									acc->including(p.totalContainerThrowEvents()))

		-- Número total de IntermediateThrowEvents de um modelo
		totalNumberModelIntermediateThrowEvents(): Integer = self.process_a->collect(totalNumberIntermediateThrowEvents())->sum()

		-- Mostra todos os IntermediateThrowEvents de um modelo
		totalModelIntermediateThrowEvents(): Set(Set(IntermediateThrowEvent)) =
			self.process_a->iterate(p; acc: Set(Set(IntermediateThrowEvent)) = Set{} | 
									acc->including(p.totalContainerIntermediateThrowEvents()))

		-- Número total de ImplicitThrowEvents de um modelo
		totalNumberModelImplicitThrowEvents(): Integer = self.process_a->collect(totalNumberContainerImplicitThrowEvents())->sum()

		-- Mostra todos os ImplicitThrowEvents de um modelo
		totalModelImplicitThrowEvents(): Set(Set(ImplicitThrowEvent)) =
			self.process_a->iterate(p; acc: Set(Set(ImplicitThrowEvent)) = Set{} | 
									acc->including(p.totalContainerImplicitThrowEvents()))

		-- Número total de CatchEvents de um modelo
		totalNumberModelCatchEvents(): Integer = self.process_a->collect(totalNumberContainerCatchEvents())->sum()

		-- Mostra todos os CatchEvents de um modelo
		totalModelCatchEvents(): Set(Set(CatchEvent)) =
			self.process_a->iterate(p; acc: Set(Set(CatchEvent)) = Set{} | 
									acc->including(p.totalContainerCatchEvents()))

		-- Número total de IntermediateCatchEvents de um modelo
		totalNumberModelIntermediateCatchEvents(): Integer = self.process_a->collect(totalNumberContainerIntermediateCatchEvents())->sum()

		-- Mostra todos os IntermediateCatchEvents de um modelo
		totalModelIntermediateCatchEvents(): Set(Set(IntermediateCatchEvent)) =
			self.process_a->iterate(p; acc: Set(Set(IntermediateCatchEvent)) = Set{} | 
									acc->including(p.totalContainerIntermediateCatchEvents()))

		-- Número total de BoundaryEvents de um modelo
		totalNumberModelBoundaryEvents(): Integer = self.process_a->collect(totalNumberContainerBoundaryEvents())->sum()

		-- Mostra todos os BoundaryEvents de um modelo
		totalModelBoundaryEvents(): Set(Set(BoundaryEvent)) =
			self.process_a->iterate(p; acc: Set(Set(BoundaryEvent)) = Set{} | 
									acc->including(p.totalContainerBoundaryEvents()))

		-- Número total de gateways de um modelo
		totalNumberModelGateways(): Integer = self.process_a->collect(totalNumberContainerGateways())->sum()
		
		-- Mostra todas as Gateways de um modelo
		totalModelGateways(): Set(Set(Gateway)) =
			self.process_a->iterate(p; acc: Set(Set(Gateway)) = Set{} | 
									acc->including(p.totalContainerGateways()))
							
		-- Número total de EventBasedGateways de um modelo
		totalNumberModelEventBasedGateways(): Integer = self.process_a->collect(totalNumberContainerEventBasedGateways())->sum()
		
		-- Mostra todas as EventBasedGateways de um modelo
		totalModelEventBasedGateways(): Set(Set(EventBasedGateway)) =
			self.process_a->iterate(p; acc: Set(Set(EventBasedGateway)) = Set{} | 
									acc->including(p.totalContainerEventBasedGateways()))	
							
		-- Número total de ExclusiveGateways de um modelo
		totalNumberModelExclusiveGateways(): Integer = self.process_a->collect(totalNumberContainerExclusiveGateways())->sum()

		-- Mostra todas as ExclusiveGateways de um modelo
		totalModelExclusiveGateways(): Set(Set(ExclusiveGateway)) =
			self.process_a->iterate(p; acc: Set(Set(ExclusiveGateway)) = Set{} | 
									acc->including(p.totalContainerExclusiveGateways()))	
									
		-- Número total de InclusiveGateways de um modelo 
		totalNumberModelInclusiveGateways(): Integer = self.process_a->collect(totalNumberContainerInclusiveGateways())->sum()
		
		-- Mostra todas as InclusiveGateways de um modelo
		totalModelInclusiveGateways(): Set(Set(InclusiveGateway)) =
			self.process_a->iterate(p; acc: Set(Set(InclusiveGateway)) = Set{} | 
									acc->including(p.totalContainerInclusiveGateways()))	

		-- Número total de ParallelGateways de um modelo 
		totalNumberModelParallelGateways(): Integer = self.process_a->collect(totalNumberContainerParallelGateways())->sum()
		
		-- Mostra todas as ParallelGateways de um modelo
		totalModelParallelGateways(): Set(Set(ParallelGateway)) =
			self.process_a->iterate(p; acc: Set(Set(ParallelGateway)) = Set{} | 
									acc->including(p.totalContainerParallelGateways()))	

		-- Número total de ComplexGateways de um modelo
		totalNumberModelComplexGateways(): Integer = self.process_a->collect(totalNumberContainerComplexGateways())->sum()
		
		-- Mostra todas as ComplexGateways de um modelo
		totalModelComplexGateways(): Set(Set(ComplexGateway)) =
			self.process_a->iterate(p; acc: Set(Set(ComplexGateway)) = Set{} | 
									acc->including(p.totalContainerComplexGateways()))	

		-- Número total de Gates de um modelo 
		totalNumberModelGates(): Integer = self.process_a->collect(totalNumberContainerGates())->sum()
		
		-- Mostra todas as Gates(Input e Output) de um modelo
		totalModelGates(): Set(Set(SequenceFlow)) =
			self.process_a->iterate(p; acc: Set(Set(SequenceFlow)) = Set{} | 
									acc->including(p.totalContainerGates()))	
		
		-- Número total de sequenceFlow input de um modelo 
		totalNumberModelInputGates(): Integer = self.process_a->collect(totalNumberContainerInputGates())->sum()
		
		-- Mostra todas as  sequenceFlow input de um modelo
		totalModelInputGates(): Set(Set(SequenceFlow)) =
			self.process_a->iterate(p; acc: Set(Set(SequenceFlow)) = Set{} | 
									acc->including(p.totalContainerInputGates()))	
		
		-- Número total de sequenceFlow output de um modelo 
		totalNumberModelOutputGates(): Integer = self.process_a->collect(totalNumberContainerOutputGates())->sum()
		
		-- Mostra todas as sequenceFlow output de um modelo
		totalModelOutputGates(): Set(Set(SequenceFlow)) =
			self.process_a->iterate(p; acc: Set(Set(SequenceFlow)) = Set{} | 
									acc->including(p.totalContainerOutputGates()))	
		
		-- Número total de Artifacts (textAnnotations and groups) de um modelo 
		totalNumberModelArtifacts(): Integer = self.process_a->collect(totalNumberContainerArtifacts())->sum()
		
		-- Mostra todos os Artifacts (textAnnotations and groups) de um modelo
		totalModelArtifacts(): Set(Set(Artifact)) =
			self.process_a->iterate(p; acc: Set(Set(Artifact)) = Set{} | 
									acc->including(p.totalContainerArtifacts()))	

		-- Número total de TextAnnotations de um modelo
		totalNumberModelTextAnnotations(): Integer = self.process_a->collect(totalNumberContainerTextAnnotations())->sum()
		
		-- Mostra todos os TextAnnotations de um modelo
		totalModelTextAnnotations(): Set(Set(TextAnnotation)) =
			self.process_a->iterate(p; acc: Set(Set(TextAnnotation)) = Set{} | 
									acc->including(p.totalContainerTextAnnotations()))	

		-- Número total de Groups de um modelo
		totalNumberModelGroups(): Integer = self.process_a->collect(totalNumberContainerGroups())->sum()
		
		-- Mostra todos os Groups de um modelo
		totalModelGroups(): Set(Set(Group)) =
			self.process_a->iterate(p; acc: Set(Set(Group)) = Set{} | 
									acc->including(p.totalContainerGroups()))	

		-- Número total de DataElements de um modelo
		totalNumberModelDataElements(): Integer = self.process_a->collect(totalNumberContainerDataElements())->sum()
		
		-- Mostra todos os DataElements de um modelo
		totalModelDataElements(): Set(Set(ItemAwareElement)) =
			self.process_a->iterate(p; acc: Set(Set(ItemAwareElement)) = Set{} | 
									acc->including(p.totalContainerDataElements()))	

		-- Número total de Connectores de um modelo
		totalNumberModelConnectors(): Integer = self.process_a->collect(totalNumberContainerConnectors())->sum()

		-- Número total de SequenceFlows de um modelo
		totalNumberModelSequenceFlows(): Integer = self.process_a->collect(totalNumberContainerSequenceFlows())->sum()
		 
		-- Mostra todos os SequenceFlows de um modelo
		totalModelSequenceFlows(): Set(Set(SequenceFlow)) =
			self.process_a->iterate(p; acc: Set(Set(SequenceFlow)) = Set{} | 
									acc->including(p.totalContainerSequenceFlows()))	

		-- Número total de MessageFlows de um modelo
		totalNumberModelMessageFlows(): Integer = self.process_a->collect(totalNumberContainerMessageFlows())->sum()

		-- Mostra todos os MessageFlows de um modelo
		totalModelMessageFlows(): Set(Set(MessageFlow)) =
			self.process_a->iterate(p; acc: Set(Set(MessageFlow)) = Set{} | 
									acc->including(p.totalContainerMessageFlows()))	

		-- Número total de Associations de um modelo
		totalNumberModelAssociations(): Integer = self.process_a->collect(totalNumberContainerAssociations())->sum()
		
		-- Mostra todas as Associations de um modelo
		totalModelAssociations(): Set(Set(Association)) =
			self.process_a->iterate(p; acc: Set(Set(Association)) = Set{} | 
									acc->including(p.totalContainerAssociations()))	

		-- Número total de DataAssociations de um modelo
		totalNumberModelDataAssociations(): Integer = self.process_a->collect(totalNumberContainerDataAssociations())->sum()
		
		-- Mostra todas as Associations de um modelo
		totalModelDataAssociations(): Set(Set(DataAssociation)) =
			self.process_a->iterate(p; acc: Set(Set(DataAssociation)) = Set{} | 
									acc->including(p.totalContainerDataAssociations()))	

		------------------------------------- Fim das Métricas de Tamanho do Modelo ------------------------------------------------------

		------------------------------------ Metricas para calcular a complexidade do Modelo ------------------------------------------	

		----------------------------------------------------- Metrica CFC --------------------------------------------------------------

		-- Métrica CFC (Control Flow Complexity) - calcula a complexidade de um modelo, adicionando os XORs, ORs e ANDs dos processos
		complexityModelCFC (): Integer = self.process_a -> collect(complexityProcessCFC()) -> sum()

		----------------------------------------------------- Metrica CFC --------------------------------------------------------------

		---------------------------------------------------- Metrica HPC ---------------------------------------------------------------
		-- Métrica HPC (Halstead-based Process Complexity) - calcula a complexidade de um modelo, estimando o comprimento, 
		-- o volume e a dificuldade do modelo
		
		-- Comprimento do modelo: Para cada processo: N=n1*log2(n1) + n2*log2(n2)
		lengthModel(): Real = self.process_a -> collect(length()) -> sum()
		
		-- Volume do modelo: Para cada processo: V=(N1 + N2)*log2(n1+n2)
		volumeModel(): Real = self.process_a -> collect(volume()) -> sum()

		-- Dificuldade do modelo: Para cada processo: D=(n1/2)*(N2/n2)
		difficultyModel(): Real = self.process_a -> collect(difficulty()) -> sum()
	
		---------------------------------------------------- Metrica HPC ---------------------------------------------------------------

		----------------------------------------------------- Metrica CNC --------------------------------------------------------------

		-- Métrica CNC (Coefficient of Network Complexity) - calcula a complexidade do modelo, dividindo o número de arcos (conectores) 
		-- pelo número de nós, ou seja, nós = (actividades, eventos e gateways(joins e splits)) do modelo			

		-- Métrica CNC (Coefficient of Network Complexity) = total de Sequence Connectors /totalNumberModelFlowObjects()
		complexityModelCNC (): Real = self.process_a -> collect(complexityProcessCNC()) -> sum()

		-- ou
		-- complexityModelCNC (): Real = totalNumberModelSequenceFlows() / totalNumberModelFlowObjects()

		----------------------------------------------------- Metrica CNC --------------------------------------------------------------

		------------------------------------------------- Complexidade do Modelo --------------------------------------------------------


		------------------------------------ Metrica para calcular a Estrutura do Modelo ---------------------------------------------	

		-- Métrica Nesting depth - Definida a estrutura do modelo, quanto maior for o valor do Nesting depth mais complexo é o modelo
		-- A Métrica Nesting depth de um elemento implica o número de decisões no fluxo de controlo que são necessárias para alcançar esse elemento

		-- A Métrica Nesting depth deve percorrer um dado caminho com um inicio e um destino e contar o número de gateways
		nestingDepthModel(origin: FlowNode, destination: FlowNode) : Integer = 
			self.process_a ->	collect(nestingDepth(origin, destination)) -> asSet() -> sum()																							
														 					 															
		--Métrica Complexidade BPM = Nesting depth + CFC
		complexityModelBPM(origin: FlowNode, destination: FlowNode) : Integer = 
			self.process_a -> collect(complexityBPM(origin, destination)) -> asSet() -> sum()

		-------------------------------------------------------- Origem ------------------------------------------------------------------------------------------

		-- A Métrica Nesting depth deve percorrer um dado caminho com um inicio e conta o número de gateways
		nestingDepthModelO(origin: FlowNode) : Integer = self.process_a -> collect(nestingDepthO(origin)) -> asSet() -> sum()																							
														 					 															
		--Métrica Complexidade BPM = Nesting depth + CFC
		complexityModelBPMO(origin: FlowNode) : Integer = self.process_a -> collect(complexityBPMO(origin)) -> asSet() -> sum()

		---------------------------------------------- Estrutura do Modelo ------------------------------------------------------------

	
		------------------------------ Metricas para calcular a modularização do Modelo -----------------------------------------------	

		-- Métrica HKM (Henry and Kafura Metric) - Define a boa ou má modularização de um modelo através do size e dos fluxos de entrada e de saída.
		-- Métrica HKM = número total de flowNodes (actividades, eventos e gateways) x (starts (fan-in) x ends(fan-out))^2

		-- Métrica HKM = número total de actividades (tasks e subprocessos) x (nº de startevents (fan-in) x nº de endevents (fan-out))^2
		modularizationModelHKM(): Real = self.process_a -> collect(modularizationProcessHKM())-> sum()

		---------------------------------------------- Modularização do Modelo -------------------------------------------------------

 end --Collaboration

 class MessageFlow < BaseElement
	attributes
		name : String
	operations
		-- returns the successors of the current MessageFlow 
		successors1(): Set(OclAny) = oclEmpty(Set(OclAny))->including(self.targetRef)->union(self.associations())

		-- returns the pool where is located the source of current MessageFlow 
		sourcePool() : Set(Participant) = 
				if self.sourceRef.oclIsTypeOf(Participant) then
						oclEmpty(Set(Participant))->including(self.sourceRef.oclAsType(Participant))
				else
						if self.sourceRef.oclIsTypeOf(ConversationNode) then
								self.sourceRef.oclAsType(ConversationNode).participantRefs
						else
								self.sourceRef.oclAsType(InteractionNode).messagePool(self.sourceRef)
						endif
				endif
				
		-- returns the pool where is located the target of current MessageFlow 
		targetPool() : Set(Participant) = 
				if self.targetRef.oclIsTypeOf(Participant) then
						oclEmpty(Set(Participant))->including(self.targetRef.oclAsType(Participant))
				else
						if self.targetRef.oclIsTypeOf(ConversationNode) then
								self.targetRef.oclAsType(ConversationNode).participantRefs
						else
								self.targetRef.oclAsType(InteractionNode).messagePool(self.targetRef)
						endif
				endif

	-- A Message Flow should be named with the name of the Message
  -- TO DO
    hasMessageName(): Boolean = true



 end --MessageFlow

 class MessageFlowAssociation < BaseElement
 end --MessageFlowAssociation

 class Participant < BaseElement, InteractionNode
	attributes
		name : String
	operations
	-- Returns the successors of the current Pool
		successors1(): Set(OclAny) = 
	 									if totalNumberLanes() > 0 then
								 				self.totalLaneSets()	-- laneSets
											-> union(self.successors1_InteractionNode())
											->union(self.associations())-> asSet()
	 									else
											self.processRef.flowElements->select(oclIsKindOf(FlowNode))
											-> select(oclAsType(FlowNode).withoutInputSequenceFlows()) 
											-> union(self.successors1_InteractionNode())
											->union(self.associations())-> asSet()
	 									endif

	-- Returns the elements successors of the current container 
	 	successors(): Set(OclAny) =  
	 									if totalNumberLanes() > 0 then
								 				self.totalLanes()	-- lanes
								 				-> union(self.successors_InteractionNode())	-- interactionNode
								 				-> union(self.successors_Association())-> asSet()	-- artifacts
	 									else
	 											self.processRef.flowElements->select(oclIsKindOf(FlowNode)) 
	 											->select(oclAsType(FlowNode).withoutInputSequenceFlows()) 
								 				-> union(self.successors_InteractionNode())	-- interactionNode
								 				-> union(self.successors_Association())-> asSet()	-- artifacts
	 									endif

 		-- retorna o processo associado ao corrente participante (Pool) 
		relatedProcess(): Process = self.processRef

		-- retorna as laneSets associadas à corrente pool
		totalLaneSets() : Set(LaneSet) = self.lane_a.laneSet->select(oclIsKindOf(LaneSet))->collect(oclAsType(LaneSet)) -> asSet()

		-- retorna as lanes associadas à corrente pool
		totalLanes() : Set(Lane) = self.lane_a->select(oclIsKindOf(Lane))->collect(oclAsType(Lane)) -> asSet()
		
		-- retorna as lanes associadas à corrente pool
		totalNumberLanes(): Integer = self.totalLanes()->size()
		
		-- retorna os participantes (Pools) contidos pelo corrente participante
		innerParticipants(): Set(Participant) = self.participantAssociation_a.innerParticipantRef->asSet()

		-- retorna os participantes (Pools) que contêm o corrente participante
		outerParticipants(): Set(Participant) = self.participantAssociation.outerParticipantRef->asSet()

		-- retorna os partnerEntity do corrente participante
		partnerEntity(): Set(PartnerEntity) = self.partnerEntityRef->asSet()

		-- retorna os partnerRole do corrente participante
		partnerRole(): Set(PartnerRole) = self.partnerRoleRef->asSet()

		-- retorna true se puder existir multiplas instâncias do corrente participante 
		isMultiInstance(): Boolean = self.participantMultiplicity.maximum = oclUndefined(Integer) or 
																	self.participantMultiplicity.maximum > 1

		-- retorna as interfaces definidas pelo corrente participante 
		interfaces(): Set(Interface) = self.interfaceRefs -> asSet()

		-- retorna as GlobalChoreographyTask definidas que o corrente participante inicia
		globalChoreographyTask(): Set(GlobalChoreographyTask) = self.globalChoreographyTask 

		-- retorna as choreographyActivity definidas  que o corrente participante inicia
		choreographyActivity(): Set(ChoreographyActivity) = self.choreographyActivity ->asSet()

		-- retorna o conjunto de participante que participam na choreographyActivity 
		choreographyActivityParticipants(): Set(Participant) = self.choreographyActivity.participantRefs->asSet()

		-- retorna true se o processo da pool não contiver elementos
		isBlackBox() : Boolean =
		self.processRef.bpmnElements()->size() = 0
		
		-- retorna true se o processo da pool contiver elementos
		isWhiteBox() : Boolean =
		self.processRef.bpmnElements()->reject(oclIsTypeOf(MessageFlow))->size() > 0
		
 end --Participant

 class ParticipantAssociation < BaseElement
 end --ParticipantAssociation

 class CallConversation < ConversationNode
 end --CallConversation

 class Conversation < ConversationNode
 end --Conversation

 class ConversationAssociation < BaseElement
 end --ConversationAssociation

 class ConversationLink < BaseElement
	attributes
		name : String
 end --ConversationLink

 class GlobalConversation < Collaboration
 end --GlobalConversation

 class SubConversation < ConversationNode
 end --SubConversation

 class CorrelationKey < BaseElement
	attributes
		name : String
 end --CorrelationKey

 class CorrelationProperty < RootElement
	attributes
		name : String
 end --CorrelationProperty

 class CorrelationPropertyBinding < BaseElement
 end --CorrelationPropertyBinding

 class CorrelationPropertyRetrievalExpression < BaseElement
 end --CorrelationPropertyRetrievalExpression

 class CorrelationSubscription < BaseElement
 end --CorrelationSubscription

 class Error < RootElement
	attributes
		name : String
		errorCode : String
 end --Error

 class Expression < BaseElement
 end --Expression

 class FormalExpression < Expression
	attributes
		language : String
		body : Element
 end --FormalExpression

 class ItemDefinition < RootElement
	attributes
		itemKind : ItemKind
		structureRef : Element
		isCollection : Boolean
 end --ItemDefinition

 class Message < RootElement
	attributes
		name : String
 end --Message

 class PartnerEntity < RootElement
	attributes
		name : String
 end --PartnerEntity

 class PartnerRole < RootElement
	attributes
		name : String
 end --PartnerRole

 class Resource < RootElement
	attributes
		name : String
 end --Resource

 class ResourceParameter < BaseElement
	attributes
		name : String
		isRequired : Boolean
 end --ResourceParameter

 class SequenceFlow < FlowElement
	attributes
		isImmediate : Boolean
	operations
		-- returns the successors of the current SequenceFlow 
		successors1(): Set(OclAny) = if self.targetRef.oclIsKindOf(SubProcess) and 
																						self.targetRef.oclAsType(SubProcess).successors1_inside()->notEmpty() then
																			self.targetRef.oclAsType(SubProcess).successors1_inside() 
																			->union(self.associations())-> asSet()
																else
																	oclEmpty(Set(OclAny))->including(self.targetRef)->union(self.associations())
																endif

		-- returns the pool where is located the source of current SequenceFlow 
		sourcePool() : Set(Participant) = pool(self.sourceRef)
			
		-- returns the pool where is located the target of current SequenceFlow 
		targetPool() : Set(Participant) = pool(self.targetRef)
			

		-- returns true if the current SequenceFlow comes from a non exclusive path, i.e.,
		-- the source element or a precedent element of the SequenceFlow source element is:
		-- an activity with several outgoing sequence flow without condition
		-- an event with several outgoing sequence flow
		-- a non interrupting boundary event 
		-- a parallel/inclusive/EventBasedParallel gateway
		isNonExclusive() : Boolean = 
						self.targetRef.precedentNonExclusiveSplitElements()->size() > 0

		-- returns true if the current SequenceFlow comes from a  exclusive path, i.e.,
		-- an activity with several outgoing sequence flow with conditions
		-- a flow node with only one outgoing sequence flow
		-- a interrupting boundary event 
		-- a exclusive/EventBased gateway
		isExclusive() : Boolean = 
						self.targetRef.precedentExclusiveSplitElements()->size() > 0

 end --SequenceFlow

 class Documentation < BaseElement
	attributes
		text : String
		textFormat : String
 end --Documentation

 class Relationship < BaseElement
	attributes
		type : String
		direction : RelationshipDirection
 end --Relationship

 class EndPoint < RootElement
 end --EndPoint

 class Interface < RootElement
	attributes
		name : String
		implementationRef : Element
 end --Interface

 class Operation < BaseElement
	attributes
		name : String
		implementationRef : Element
 end --Operation

 class Assignment < BaseElement
 end --Assignment

 class DataAssociation < BaseElement

 end --DataAssociation

 class DataInput < ItemAwareElement
	attributes
		name : String
		isCollection : Boolean
 end --DataInput

 class DataInputAssociation < DataAssociation
  	operations
		-- Returns the successors of the current DataInputAssociation
		successors1(): Set(OclAny) = oclEmpty(Set(OclAny))->including(self.activity)
										->including(self.sourceRef)				-- foi incluido o DataSource de onde é feito o input 
 end --DataInputAssociation

 class DataObject < FlowElement, ItemAwareElement
	attributes
		isCollection : Boolean
 end --DataObject

 class DataObjectReference < ItemAwareElement, FlowElement
 
 operations
 
 	-- Data Object References can only access Data Objects residing 
	-- in the same container or their parents
	-- TO DO
	isDataObjectAtSameContainerOrParent() : Boolean = true

 end --DataObjectReference

 class DataOutput < ItemAwareElement
	attributes
		name : String
		isCollection : Boolean
 end --DataOutput

 class DataOutputAssociation < DataAssociation
  	operations
		-- Returns the successors of the current DataOutputAssociation
		successors1(): Set(OclAny) = oclEmpty(Set(OclAny))->including(self.targetRef)
 end --DataOutputAssociation

 class DataState < BaseElement
	attributes
		name : String
 end --DataState

 class DataStore < ItemAwareElement, RootElement
	attributes
		name : String
		capacity : Integer
		isUnlimited : Boolean
 end --DataStore

 class DataStoreReference < FlowElement, ItemAwareElement
 end --DataStoreReference

 class InputOutputSpecification < BaseElement
 end --InputOutputSpecification

 class InputSet < BaseElement
	attributes
		name : String
 end --InputSet

 class ItemAwareElement < BaseElement
	operations
			-- Returns the successors of an ItemAwareElement 
		successors1(): Set(OclAny) = self.dataAssociation_a
																->union(self.dataAssociation)
																->union(self.associations())

	-- Returns the successors of the current node 
	successors(): Set(OclAny) = self.successors_ItemAwareElement()->asSet()

	-- Returns the itemAwareElements successors of the dataAssociation of the current node 
	successors_ItemAwareElement(): Set(OclAny) = self.dataAssociation->select(oclIsKindOf(DataOutputAssociation))
																				-> collect(oclAsType(DataOutputAssociation)).activity
																				-> union(self.dataAssociation->select(oclIsKindOf(DataInputAssociation))
																				-> collect(oclAsType(DataInputAssociation)).activity)
																				-> union(self.dataAssociation_a->select(oclIsKindOf(DataOutputAssociation))
																				-> collect(oclAsType(DataOutputAssociation)).activity)
																				->union(self.dataAssociation_a->select(oclIsKindOf(DataInputAssociation))
																				-> collect(oclAsType(DataInputAssociation)).activity)->asSet()

 end --ItemAwareElement

 class OutputSet < BaseElement
	attributes
		name : String
 end --OutputSet

 class Property < ItemAwareElement
	attributes
		name : String
 end --Property

 class BoundaryEvent < CatchEvent
	attributes
		cancelActivity : Boolean
	operations
	
	-- An attached non-interrupting event simply creates an additional token if it 
	-- occurs during the execution of the respective activity. If both sequence flows 
	-- (normal and non-interrupting) should be merged by a gateway, an inclusive 
	-- gateway would be required.
		pathMergedByAnInclusiveGateway() : Boolean =
			(self.attachedToRef.container.computeFlowNodes(self.attachedToRef)
			-> flatten()->asSet() 
			->intersection(self.attachedToRef.container.computeFlowNodes(self)
			-> flatten())->size() > 0
			and
			self.isNonInterruptingEvent())
		implies
			self.attachedToRef.container.computeFlowNodes(self.attachedToRef)
			-> flatten()->asSet() 
			->intersection(self.attachedToRef.container.computeFlowNodes(self)-> flatten())
			->exists(oclIsTypeOf(InclusiveGateway))

	-- An attached interrupting event simply creates an token if it 
	-- occurs during the execution of the respective activity. If both sequence flows 
	-- (normal and interrupting) should be merged by a gateway, an exclusive 
	-- gateway would be required.
		pathMergedByAnExclusiveGateway() : Boolean =
			(self.attachedToRef.container.computeFlowNodes(self.attachedToRef)
			-> flatten()->asSet() 
			->intersection(self.attachedToRef.container.computeFlowNodes(self)
			-> flatten())->size() > 0
			and
			self.isInterruptingEvent())
		implies
			self.attachedToRef.container.computeFlowNodes(self.attachedToRef)-> flatten()->asSet() 
			->intersection(self.attachedToRef.container.computeFlowNodes(self)-> flatten())
			->select(oclIsTypeOf(ExclusiveGateway))->size()>0

	
 end --BoundaryEvent

 class CancelEventDefinition < EventDefinition
 end --CancelEventDefinition

 class CompensateEventDefinition < EventDefinition
	attributes
		waitForCompletion : Boolean
 end --CompensateEventDefinition

 class ConditionalEventDefinition < EventDefinition
 end --ConditionalEventDefinition

 class EndEvent < ThrowEvent
 end --EndEvent

 class ErrorEventDefinition < EventDefinition
 end --ErrorEventDefinition

 class EscalationEventDefinition < EventDefinition
 end --EscalationEventDefinition

 class ImplicitThrowEvent < ThrowEvent
 end --ImplicitThrowEvent

 class IntermediateCatchEvent < CatchEvent
 
 operations
 	  -- An Event must have a name
		-- TO DO
	hasName(): Boolean = true

		-- A Catching Intermediate Message Event should have an incoming Message flow
		-- TO DO
	    hasMessageFlow(): Boolean = true
 
 end --IntermediateCatchEvent

 class IntermediateThrowEvent < ThrowEvent
 operations
 	  -- An Event must have a name
		-- TO DO
	hasName(): Boolean = true

		-- A Throwing Intermediate Message Event should have an outgoing Message flow
		-- TO DO
	    hasMessageFlow(): Boolean = true

 end --IntermediateThrowEvent

 class LinkEventDefinition < EventDefinition
	attributes
		name : String
 end --LinkEventDefinition

 class MessageEventDefinition < EventDefinition
 end --MessageEventDefinition

 class Signal < RootElement
	attributes
		name : String
 end --Signal

 class SignalEventDefinition < EventDefinition
 end --SignalEventDefinition

 class StartEvent < CatchEvent
	attributes
		isInterrupting : Boolean
		
		operations
		
		
	-- The non-interrupting variants of message events,  conditional events, 
	-- timer events, signal events, multiple events, and parallel multiple events 
	-- are only possible within an event sub-process, but not in a normal process.
	isContainerEventSubProcess()  : Boolean =
			((self.isMessageEvent() or 
			self.isConditionalEvent() or 
			self.isTimerEvent() or 
			self.isSignalEvent() or 
			self.isMultipleEvent() or 
			self.isParallelMultipleEvent()) 
			and self.isInterrupting = false)
			implies
				(self.container.oclIsTypeOf(SubProcess) and
				self.container.oclAsType(SubProcess).isEventSubProcess())

	-- Top-level processes can have seven types of start events: none,
	-- message, timer, conditional, signal, multiple, and parallel (page
	-- 112).
	isContainerTopLevelProcess() : Boolean =
	self.container.isTopLevelProcess() implies 
	(self.isNoneEvent() or self.isMessageEvent() or self.isTimerEvent() or 
	self.isConditionalEvent() or self.isSignalEvent() or self.isMultipleEvent() or 
	self.isParallelMultipleEvent())

	  -- A Start Event must have a name
		-- TO DO
	hasName(): Boolean = true


		-- A Message Start Event should have an incoming Message Flow
		-- TO DO
    hasMessageFlow(): Boolean = true

 end --StartEvent

 class TerminateEventDefinition < EventDefinition
 end --TerminateEventDefinition

 class TimerEventDefinition < EventDefinition
 end --TimerEventDefinition

 class ComplexGateway < Gateway
 end --ComplexGateway

 class EventBasedGateway < Gateway
	attributes
		instantiate : Boolean
		eventGatewayType : EventBasedGatewayType
		
		operations
		
		 existsTimerIntermediateEvent():Boolean = true
 end --EventBasedGateway

 class ExclusiveGateway < Gateway
 
 operations
 
 		-- Use a Default Condition at an Exclusive Gateway
 		-- TO DO
     existsDefaultCondition():Boolean = true
 
 end --ExclusiveGateway

 class InclusiveGateway < Gateway

 operations
 		-- Use a Default Condition at an Inclusive Gateway
 		-- TO DO
     existsDefaultCondition():Boolean = true
     
   -- create models where a merging Inclusive Gateway follows a splitting 
  -- Inclusive Gateway and that the number of Sequence Flow matches between them
 		-- TO DO
    isMergingAndSplittingMatching():Boolean = true

     
 end --InclusiveGateway

 class ParallelGateway < Gateway
 
  operations
 		-- Ensure that the number of incoming Sequence Flow is correct for a Parallel Gateway
 		-- TO DO
	 notDeadlock():Boolean = true
	 
  -- Match merging and splitting Sequence Flow in Parallel Gateways 
  -- (if the desired behavior is to merge them again)
 		-- TO DO
    isMergingAndSplittingMatching():Boolean = true
	 
	 
 end --ParallelGateway

 class GlobalManualTask < GlobalTask
 end --GlobalManualTask

 class GlobalUserTask < GlobalTask
	attributes
		implementation : String
 end --GlobalUserTask

 class HumanPerformer < Performer
 end --HumanPerformer

 class ManualTask < Task
 end --ManualTask

 class PotentialOwner < HumanPerformer
 end --PotentialOwner

 class Rendering < BaseElement
 end --Rendering

 class UserTask < Task
	attributes
		implementation : String
 end --UserTask

 class Definitions < BaseElement
	attributes
		name : String
		targetNamespace : String
		expressionLanguage : String
		typeLanguage : String
		exporter : String
		exporterVersion : String
 end --Definitions

 class Auditing < BaseElement
 end --Auditing

 class GlobalTask < CallableElement
 end --GlobalTask

 class Lane < BaseElement
	attributes
		name : String
		
	operations
	
	-- Returns the successors of the current lane 
	successors1(): Set(OclAny) = self.flowNodeRefs-> select(oclIsKindOf(FlowNode))		
										-> select(oclAsType(FlowNode).withoutInputSequenceFlows()) -- flowNodes
											->union(self.associations())-> asSet()

	-- Returns the elements successors of the current laneSet 
	successors(): Set(OclAny) = self.flowNodeRefs-> select(oclIsKindOf(FlowNode))	
												-> select(oclAsType(FlowNode).withoutInputSequenceFlows()) -- flowNodes
								 				-> union(self.successors_Association())-> asSet()	-- artifacts

	
	-- retorna a laneSet (se existir) contida na corrente lane
	childLaneSet() : LaneSet = self.childLaneSet
	
	-- retorna a laneSet (se existir) que contém a corrente lane
	laneSet() : LaneSet = self.laneSet
	
	-- retorna os flowNodes contidos na corrente lane
	flowNodes() : Set(FlowNode) = self.flowNodeRefs
	
	-- retorna a pool (participant) associada à corrente lane
	currentParticipant() : Participant = 
			if self.partitionElementRef.oclIsKindOf(Participant) then
					self.partitionElementRef.oclAsType(Participant)
			else
					oclUndefined(Participant)
			endif

	-- retorna as gateways contidas na corrente lane
	totalLaneGateways() : Set(Gateway) = self.flowNodes()
															->select(oclIsKindOf(Gateway))->collect(oclAsType(Gateway)) -> asSet()

	-- retorna as activities contidas na corrente lane
	totalLaneActivities() : Set(Activity) = self.flowNodes()
															->select(oclIsKindOf(Activity))->collect(oclAsType(Activity)) -> asSet()

	-- retorna as tasks contidas na corrente lane
	totalLaneTasks() : Set(Task) = self.flowNodes()
															->select(oclIsKindOf(Task))->collect(oclAsType(Task)) -> asSet()

	-- retorna os SubProcesses contidos na corrente lane
	totalLaneSubProcesses() : Set(SubProcess) = self.flowNodes()
															->select(oclIsKindOf(SubProcess))->collect(oclAsType(SubProcess)) -> asSet()

	-- retorna os events contidos na corrente lane
	totalLaneEvents() : Set(Event) = self.flowNodes()
															->select(oclIsKindOf(Event))->collect(oclAsType(Event)) -> asSet()

	-- retorna os artifacts contidos na corrente lane
	totalLaneArtifacts() : Set(Artifact) = oclEmpty(Set(OclAny))->including(self)->union(self.flowNodes())
															->select(oclIsKindOf(BaseElement))->collect(oclAsType(BaseElement).artifacts()) -> asSet()

	-- retorna os dataElements contidos na corrente lane
	totalLaneDataElements() : Set(ItemAwareElement) = self.flowNodes()
													->select(oclIsKindOf(Activity))
													->collect(oclAsType(Activity).dataElements())->asSet()

	-- retorna os elementos contidos na corrente lane
	bpmnElements(): Set(BaseElement) =self.flowNodes()->union(self.totalLaneArtifacts())->union(self.totalLaneDataElements())->asSet()
	
 end --Lane

 class LaneSet < BaseElement
	attributes
		name : String
	operations

	-- Returns the successors of the current laneSet 
	successors1(): Set(OclAny) = 	lanes()	-- lanes
											->union(self.associations())-> asSet()

	-- Returns the elements successors of the current laneSet 
	successors(): Set(OclAny) = self.lanes	-- lanes
								 				-> union(self.successors_Association())-> asSet()	-- artifacts

	
	-- retorna a lane (se existir) que contém a corrente laneSet
	parentLane() : Lane = self.parentLane
	
	-- retorna o conjunto de lanes agrupadas pela corrente laneSet
	lanes() : Set(Lane) = self.lanes
	
 end --LaneSet

 class Monitoring < BaseElement
 end --Monitoring

 class Performer < ResourceRole
 end --Performer

 class Process < FlowElementsContainer, CallableElement
	attributes
		processType : ProcessType
		isClosed : Boolean
		isExecutable : Boolean

	operations

	-- Returns the successors (pool, message flows,sequence flows) of the current process 
	successors1(): Set(OclAny) = 
							if self.hasParticipant() then
								 self.totalContainerPools()-> asSet()	-- pools
							else
								if self.laneSets->notEmpty() then
									 self.laneSets-> asSet()	-- laneSets
								else	-- flowNodes without input sequence flows
										self.flowElements->select(oclIsKindOf(FlowNode)) 
										-> collect(oclAsType(FlowNode).withoutInputSequenceFlows()) -> asSet()
								endif
							endif

	-- Returns the elements successors of the current container 
	successors(): Set(OclAny) = 
							if self.hasParticipant()  then
								 self.totalContainerPools()->asSet()	-- pools
							else
								if self.laneSets->notEmpty() then
									 self.laneSets.lanes->asSet()	-- lanes
								else	-- flowNodes without input sequence flows
										self.flowElements->select(oclIsKindOf(FlowNode)) 
										-> collect(oclAsType(FlowNode).withoutInputSequenceFlows()) -> asSet()
								endif
							endif


		---------------------------- Metricas para calcular o Tamanho de um Processo ------------------------------------------------------
		-- Número total de pools (participants) de um processo (synonym of numberOfParticipants())
		totalNumberContainerPools(): Integer = self.totalContainerPools() -> size() 

		-- Mostra todas as pools de um processo 
		totalContainerPools(): Set(Participant) = self.participant->select(oclIsKindOf(Participant))->
												collect(oclAsType(Participant))->asSet()

		-- retorna a colaboração em que o processo participa
		processCollaboration(): Collaboration = self.definitionalCollaborationRef

		-- Indica se o processo tem Participantes (Pools) associados
		hasParticipant(): Boolean = self.participant->select(oclIsKindOf(Participant))->
												collect(oclAsType(Participant))-> size() > 0

		-- Número total de swimlanes (pools + lanes) de um container
		totalNumberContainerSwimlanes(): Integer = self.totalNumberContainerPools() + self.totalNumberContainerLanes()

		nameOfCatchingSignalEventMatchNameOfThrowingEvent() : Boolean =
	-- The name of a catching  signal events
	-- must match to the name of one of the throwing signal events.
	
	(self.participant.collaboration.participants.processRef.bpmnElements()
						->flatten()->select(oclIsKindOf(CatchEvent))
						->select(oclAsType(CatchEvent).isSignalEvent() 
												and oclAsType(CatchEvent).name.isDefined())
						->collect(oclAsType(CatchEvent).name)->asSet())
	->intersection(
	(self.participant.collaboration.participants.processRef.bpmnElements()
						->flatten()->select(oclIsKindOf(ThrowEvent))
						->select(oclAsType(ThrowEvent).isSignalEvent() 
												and oclAsType(ThrowEvent).name.isDefined())
						->collect(oclAsType(ThrowEvent).name)->asSet())
		)->size() <= 0
	and
	(self.participant.collaboration.participants.processRef.bpmnElements()
						->flatten()->select(oclIsKindOf(CatchEvent))
						->select(oclAsType(CatchEvent).isSignalEvent() 
												and oclAsType(CatchEvent).name.isUndefined())
						->asSet()->size()) >= 0
		

			-- A called top-level process can have several start events. 
			-- At least one of them should be an untyped event (page 112)
			isCallable()  : Boolean = 
				 self.oclAsType(Process).totalNumberContainerNoneStartEvents() > 1 

		-- Activities in the same Process should not have the same name
  -- TO DO
    isActivityNameUnique(): Boolean = true

 end --Process

--- Processing Association Classes 

  --Definitions_RootElement
 composition A_rootElements_definition between
	Definitions [0..1] role definition
	RootElement [0..*] role rootElements
 end --A_rootElements_definition

  --Definitions_Relationship
 composition A_relationships_definition between
	Definitions [0..1] role definition
	Relationship [0..*] role relationships
 end --A_relationships_definition

  --Definitions_Import
 composition A_imports_definition between
	Definitions [0..1] role definition
	Import [0..*] role imports
 end --A_imports_definition

  --Participant_GlobalChoreographyTask
 association A_initiatingParticipantRef_globalChoreographyTask between
	Participant [1] role initiatingParticipantRef
	GlobalChoreographyTask [0..*] role globalChoreographyTask
 end --A_initiatingParticipantRef_globalChoreographyTask

  --Collaboration_MessageFlow
 composition A_messageFlows_collaboration between
	Collaboration [0..1] role collaboration
	MessageFlow [0..*] role messageFlows
 end --A_messageFlows_collaboration

  --Collaboration_Participant
 composition A_participants_collaboration between
	Collaboration [0..1] role collaboration
	Participant [0..*] role participants
 end --A_participants_collaboration

  --Message_MessageFlow
 association A_messageRef_messageFlow between
	Message [0..1] role messageRef
	MessageFlow [0..*] role messageFlow
 end --A_messageRef_messageFlow

  --Process_Participant
 association A_processRef_participant between
	Process [0..1] role processRef
	Participant [0..*] role participant
 end --A_processRef_participant

  --Participant_Interface
 association A_interfaceRefs_participant between
	Participant [0..*] role participant
	Interface [0..*] role interfaceRefs
 end --A_interfaceRefs_participant

  --Collaboration_Choreography
 association A_choreographyRef_collaboration between
	Collaboration [0..*] role collaboration
	Choreography [0..*] role choreographyRef
 end --A_choreographyRef_collaboration

  --Interface_CallableElement
 association A_supportedInterfaceRefs_callableElements between
	Interface [0..*] role supportedInterfaceRefs
	CallableElement [0..*] role callableElements
 end --A_supportedInterfaceRefs_callableElements

  --Process_Process
 association A_supports_process between
	Process [0..*] role supports
	Process [0..*] role process
 end --A_supports_process

  --Collaboration_Process
 association A_definitionalCollaborationRef_process between
	Collaboration [0..1] role definitionalCollaborationRef
	Process [0..*] role process_a
 end --A_definitionalCollaborationRef_process

  --Definitions_Extension
 composition A_extensions_definitions between
	Definitions [0..1] role definitions
	Extension [0..*] role extensions
 end --A_extensions_definitions

  --Definitions_BPMNDiagram
 composition A_diagrams_definitions between
	Definitions [0..1] role definitions
	BPMNDiagram [0..*] role diagrams
 end --A_diagrams_definitions

  --BaseElement_Documentation
 composition A_documentation_baseElement between
	BaseElement [0..1] role baseElement
	Documentation [0..*] role documentation
 end --A_documentation_baseElement

  --ResourceRole_ResourceAssignmentExpression
 composition A_resourceAssignmentExpression_activityResource between
	ResourceRole [0..1] role activityResource
	ResourceAssignmentExpression [0..1] role resourceAssignmentExpression
 end --A_resourceAssignmentExpression_activityResource

  --ResourceRole_ResourceParameterBinding
 composition A_resourceParameterBindings_activityResource between
	ResourceRole [0..1] role activityResource
	ResourceParameterBinding [0..*] role resourceParameterBindings
 end --A_resourceParameterBindings_activityResource

  --MultiInstanceLoopCharacteristics_ComplexBehaviorDefinition
 composition A_complexBehaviorDefinition_multiInstanceLoopCharacteristics between
	MultiInstanceLoopCharacteristics [0..1] role multiInstanceLoopCharacteristics
	ComplexBehaviorDefinition [0..*] role complexBehaviorDefinition
 end --A_complexBehaviorDefinition_multiInstanceLoopCharacteristics

  --Activity_LoopCharacteristics
 composition A_loopCharacteristics_activity between
	Activity [0..1] role activity
	LoopCharacteristics [0..1] role loopCharacteristics
 end --A_loopCharacteristics_activity

  --Activity_ResourceRole
 composition A_resources_activity between
	Activity [0..1] role activity
	ResourceRole [0..*] role resources
 end --A_resources_activity

  --Activity_SequenceFlow
 association A_default_activity between
	Activity [0..1] role activity
	SequenceFlow [0..1] role default
 end --A_default_activity

  --Activity_BoundaryEvent
 association A_boundaryEventRefs_attachedToRef between
	Activity [1] role attachedToRef
	BoundaryEvent [0..*] role boundaryEventRefs
 end --A_boundaryEventRefs_attachedToRef

  --Activity_DataOutputAssociation
 composition A_dataOutputAssociations_activity between
	Activity [0..1] role activity
	DataOutputAssociation [0..*] role dataOutputAssociations
 end --A_dataOutputAssociations_activity

  --Activity_DataInputAssociation
 composition A_dataInputAssociations_activity between
	Activity [0..1] role activity
	DataInputAssociation [0..*] role dataInputAssociations
 end --A_dataInputAssociations_activity

  --Activity_InputOutputSpecification
 composition A_ioSpecification_activity between
	Activity [0..1] role activity
	InputOutputSpecification [0..1] role ioSpecification
 end --A_ioSpecification_activity

  --Activity_Property
 composition A_properties_activity between
	Activity [0..1] role activity
	Property [0..*] role properties
 end --A_properties_activity

  --CallableElement_CallActivity
 association A_calledElementRef_callActivity between
	CallableElement [0..1] role calledElementRef
	CallActivity [0..*] role callActivity
 end --A_calledElementRef_callActivity

  --FlowNode_SequenceFlow
 association A_targetRef_incoming_flow between
	FlowNode [1] role targetRef
	SequenceFlow [0..*] role incoming_a
 end --A_targetRef_incoming_flow

  --FlowNode_SequenceFlow
 association A_sourceRef_outgoing_flow between
	FlowNode [1] role sourceRef
	SequenceFlow [0..*] role outgoing_a
 end --A_sourceRef_outgoing_flow

  --FlowElementsContainer_FlowElement
 composition A_flowElements_container between
	FlowElementsContainer [1..1] role container
	FlowElement [0..*] role flowElements
 end --A_flowElements_container

  --CallableElement_InputOutputSpecification
 composition A_ioSpecification_callableElement between
	CallableElement [0..1] role callableElement
	InputOutputSpecification [0..1] role ioSpecification
 end --A_ioSpecification_callableElement

  --OutputSet_DataOutput
 association A_outputSetWithWhileExecuting_whileExecutingOutputRefs between
	OutputSet [0..*] role outputSetWithWhileExecuting
	DataOutput [0..*] role whileExecutingOutputRefs
 end --A_outputSetWithWhileExecuting_whileExecutingOutputRefs

  --OutputSet_DataOutput
 association A_outputSetWithOptional_optionalOutputRefs between
	OutputSet [0..*] role outputSetWithOptional
	DataOutput [0..*] role optionalOutputRefs
 end --A_outputSetWithOptional_optionalOutputRefs

  --InputSet_DataInput
 association A_optionalInputRefs_inputSetWithOptional between
	InputSet [0..*] role inputSetWithOptional
	DataInput [0..*] role optionalInputRefs
 end --A_optionalInputRefs_inputSetWithOptional

  --InputSet_DataInput
 association A_whileExecutingInputRefs_inputSetWithWhileExecuting between
	InputSet [0..*] role inputSetWithWhileExecuting
	DataInput [0..*] role whileExecutingInputRefs
 end --A_whileExecutingInputRefs_inputSetWithWhileExecuting

  --OutputSet_InputSet
 association A_inputSetRefs_outputSetRefs between
	OutputSet [0..*] role outputSetRefs
	InputSet [0..*] role inputSetRefs
 end --A_inputSetRefs_outputSetRefs

  --InputOutputSpecification_DataOutput
 composition A_dataOutputs_inputOutputSpecification between
	InputOutputSpecification [0..1] role inputOutputSpecification
	DataOutput [0..*] role dataOutputs
 end --A_dataOutputs_inputOutputSpecification

  --InputOutputSpecification_DataInput
 composition A_dataInputs_inputOutputSpecification between
	InputOutputSpecification [0..1] role inputOutputSpecification
	DataInput [0..*] role dataInputs
 end --A_dataInputs_inputOutputSpecification

  --InputOutputSpecification_OutputSet
 composition A_outputSets_inputOutputSpecification between
	InputOutputSpecification [0..1] role inputOutputSpecification
	OutputSet [1..*] role outputSets
 end --A_outputSets_inputOutputSpecification

  --InputOutputSpecification_InputSet
 composition A_inputSets_inputOutputSpecification between
	InputOutputSpecification [0..1] role inputOutputSpecification
	InputSet [1..*] role inputSets
 end --A_inputSets_inputOutputSpecification

  --OutputSet_DataOutput
 association A_dataOutputRefs_outputSetRefs between
	OutputSet [1..*] role outputSetRefs
	DataOutput [0..*] role dataOutputRefs
 end --A_dataOutputRefs_outputSetRefs

  --InputSet_DataInput
 association A_dataInputRefs_inputSetRefs between
	InputSet [1..*] role inputSetRefs
	DataInput [0..*] role dataInputRefs
 end --A_dataInputRefs_inputSetRefs

  --MultiInstanceLoopCharacteristics_DataOutput
 composition A_outputDataItem_multiInstanceLoopCharacteristics between
	MultiInstanceLoopCharacteristics [0..1] role multiInstanceLoopCharacteristics
	DataOutput [0..1] role outputDataItem
 end --A_outputDataItem_multiInstanceLoopCharacteristics

  --MultiInstanceLoopCharacteristics_DataInput
 composition A_inputDataItem_multiInstanceLoopCharacteristics between
	MultiInstanceLoopCharacteristics [0..1] role multiInstanceLoopCharacteristics
	DataInput [0..1] role inputDataItem
 end --A_inputDataItem_multiInstanceLoopCharacteristics

  --MultiInstanceLoopCharacteristics_ItemAwareElement
 association A_loopDataOutputRef_multiInstanceLoopCharacteristics between
	MultiInstanceLoopCharacteristics [0..1] role multiInstanceLoopCharacteristics_a
	ItemAwareElement [0..1] role loopDataOutputRef
 end --A_loopDataOutputRef_multiInstanceLoopCharacteristics

  --ItemAwareElement_MultiInstanceLoopCharacteristics
 association A_loopDataInputRef_multiInstanceLoopCharacteristics between
	ItemAwareElement [0..1] role loopDataInputRef
	MultiInstanceLoopCharacteristics [0..1] role multiInstanceLoopCharacteristics_b
 end --A_loopDataInputRef_multiInstanceLoopCharacteristics

  --StandardLoopCharacteristics_Expression
 composition A_loopMaximum_standardLoopCharacteristics between
	StandardLoopCharacteristics [0..1] role standardLoopCharacteristics_a
	Expression [0..1] role loopMaximum
 end --A_loopMaximum_standardLoopCharacteristics

  --StandardLoopCharacteristics_Expression
 composition A_loopCondition_standardLoopCharacteristics between
	StandardLoopCharacteristics [0..1] role standardLoopCharacteristics
	Expression [0..1] role loopCondition
 end --A_loopCondition_standardLoopCharacteristics

  --MultiInstanceLoopCharacteristics_Expression
 composition A_loopCardinality_multiInstanceLoopCharacteristics between
	MultiInstanceLoopCharacteristics [0..1] role multiInstanceLoopCharacteristics_a
	Expression [0..1] role loopCardinality
 end --A_loopCardinality_multiInstanceLoopCharacteristics

  --ComplexBehaviorDefinition_FormalExpression
 composition A_condition_complexBehaviorDefinition between
	ComplexBehaviorDefinition [0..1] role complexBehaviorDefinition
	FormalExpression [1] role condition
 end --A_condition_complexBehaviorDefinition

  --MultiInstanceLoopCharacteristics_Expression
 composition A_completionCondition_multiInstanceLoopCharacteristics between
	MultiInstanceLoopCharacteristics [0..1] role multiInstanceLoopCharacteristics
	Expression [0..1] role completionCondition
 end --A_completionCondition_multiInstanceLoopCharacteristics

  --EventDefinition_MultiInstanceLoopCharacteristics
 association A_oneBehaviorEventRef_multiInstanceLoopCharacteristics between
	EventDefinition [0..1] role oneBehaviorEventRef
	MultiInstanceLoopCharacteristics [0..*] role multiInstanceLoopCharacteristics_a
 end --A_oneBehaviorEventRef_multiInstanceLoopCharacteristics

  --EventDefinition_MultiInstanceLoopCharacteristics
 association A_noneBehaviorEventRef_multiInstanceLoopCharacteristics between
	EventDefinition [0..1] role noneBehaviorEventRef
	MultiInstanceLoopCharacteristics [0..*] role multiInstanceLoopCharacteristics
 end --A_noneBehaviorEventRef_multiInstanceLoopCharacteristics

  --ComplexBehaviorDefinition_ImplicitThrowEvent
 composition A_event_complexBehaviorDefinition between
	ComplexBehaviorDefinition [0..1] role complexBehaviorDefinition
	ImplicitThrowEvent [0..1] role event
 end --A_event_complexBehaviorDefinition

  --ThrowEvent_DataInput
 composition A_dataInputs_throwEvent between
	ThrowEvent [0..1] role throwEvent
	DataInput [0..*] role dataInputs
 end --A_dataInputs_throwEvent

  --ThrowEvent_EventDefinition
 composition A_eventDefinitions_throwEvent between
	ThrowEvent [0..1] role throwEvent
	EventDefinition [0..*] role eventDefinitions
 end --A_eventDefinitions_throwEvent

  --ThrowEvent_EventDefinition
 association A_eventDefinitionRefs_throwEvent between
	ThrowEvent [0..*] role throwEvent_a
	EventDefinition [0..*] role eventDefinitionRefs
 end --A_eventDefinitionRefs_throwEvent

  --ResourceParameter_ResourceParameterBinding
 association A_parameterRef_resourceParameterBinding between
	ResourceParameter [1] role parameterRef
	ResourceParameterBinding [0..*] role resourceParameterBinding
 end --A_parameterRef_resourceParameterBinding

  --Resource_ResourceRole
 association A_resourceRef_activityResource between
	Resource [0..1] role resourceRef
	ResourceRole [0..*] role activityResource
 end --A_resourceRef_activityResource

  --ResourceParameterBinding_Expression
 composition A_expression_resourceParameterBinding between
	ResourceParameterBinding [0..1] role resourceParameterBinding
	Expression [1] role expression
 end --A_expression_resourceParameterBinding

  --ResourceAssignmentExpression_Expression
 composition A_expression_resourceAssignmentExpression between
	ResourceAssignmentExpression [0..1] role resourceAssignmentExpression
	Expression [1] role expression
 end --A_expression_resourceAssignmentExpression

  --Resource_ResourceParameter
 composition A_resourceParameters_resource between
	Resource [0..1] role resource
	ResourceParameter [0..*] role resourceParameters
 end --A_resourceParameters_resource

  --Process_ResourceRole
 composition A_resources_process between
	Process [0..1] role process
	ResourceRole [0..*] role resources
 end --A_resources_process

  --Operation_SendTask
 association A_operationRef_sendTask between
	Operation [0..1] role operationRef
	SendTask [0..*] role sendTask
 end --A_operationRef_sendTask

  --Operation_ReceiveTask
 association A_operationRef_receiveTask between
	Operation [0..1] role operationRef
	ReceiveTask [0..*] role receiveTask
 end --A_operationRef_receiveTask

  --Message_ReceiveTask
 association A_messageRef_receiveTask between
	Message [0..1] role messageRef
	ReceiveTask [0..*] role receiveTask
 end --A_messageRef_receiveTask

  --Message_SendTask
 association A_messageRef_sendTask between
	Message [0..1] role messageRef
	SendTask [0..*] role sendTask
 end --A_messageRef_sendTask

  --Message_Operation
 association A_outMessageRef_operation between
	Message [0..1] role outMessageRef
	Operation [0..*] role operation_a
 end --A_outMessageRef_operation

  --Message_Operation
 association A_inMessageRef_operation between
	Message [1] role inMessageRef
	Operation [0..*] role operation
 end --A_inMessageRef_operation

  --Operation_ServiceTask
 association A_operationRef_serviceTask between
	Operation [0..1] role operationRef
	ServiceTask [0..*] role serviceTask
 end --A_operationRef_serviceTask

  --Interface_Operation
 composition A_operations_interface between
	Interface [0..1] role interface
	Operation [1..*] role operations_a
 end --A_operations_interface

  --SubProcess_Artifact
 composition A_artifacts_subProcess between
	SubProcess [0..1] role subProcess
	Artifact [0..*] role artifacts
 end --A_artifacts_subProcess

  --AdHocSubProcess_Expression
 composition A_completionCondition_adHocSubProcess between
	AdHocSubProcess [0..1] role adHocSubProcess
	Expression [1] role completionCondition
 end --A_completionCondition_adHocSubProcess

  --FlowElementsContainer_LaneSet
 composition A_laneSets_flowElementsContainer between
	FlowElementsContainer [0..1] role flowElementsContainer
	LaneSet [0..*] role laneSets
 end --A_laneSets_flowElementsContainer

  --BaseElement_Association
 association A_targetRef_incoming_association between
	BaseElement [1] role targetRef
	Association [0..*] role incoming
 end --A_targetRef_incoming_association

  --BaseElement_Association
 association A_sourceRef_outgoing_association between
	BaseElement [1] role sourceRef
	Association [0..*] role outgoing
 end --A_sourceRef_outgoing_association

  --SubChoreography_Artifact
 composition A_artifacts_subChoreography between
	SubChoreography [0..1] role subChoreography
	Artifact [0..*] role artifacts
 end --A_artifacts_subChoreography

  --Collaboration_Artifact
 composition A_artifacts_collaboration between
	Collaboration [0..1] role collaboration
	Artifact [0..*] role artifacts
 end --A_artifacts_collaboration

  --Process_Artifact
 composition A_artifacts_process between
	Process [0..1] role process
	Artifact [0..1] role artifacts
 end --A_artifacts_process

  --FlowElement_CategoryValue
 association A_categorizedFlowElements_categoryValueRef between
	FlowElement [0..*] role categorizedFlowElements
	CategoryValue [0..*] role categoryValueRef
 end --A_categorizedFlowElements_categoryValueRef

  --Category_CategoryValue
 composition A_categoryValue_category between
	Category [0..1] role category
	CategoryValue [0..*] role categoryValue
 end --A_categoryValue_category

  --Group_CategoryValue
 association A_categoryValueRef_categoryValueRef between
	Group [0..1] role categoryValueRef
	CategoryValue [*] role categoryValueRef
 end --A_categoryValueRef_categoryValueRef

  --BaseElement_BPMNEdge
 association A_bpmnEdge_BaseElement between
	BaseElement [0..1] role baseElement
	BPMNEdge [0..*] role edge
 end --A_bpmnEdge_BaseElement

  --DiagramElement_BPMNEdge
 association A_bpmnEdge_diagramElement_target between
	DiagramElement [0..1] role diagramElement_target
	BPMNEdge [0..*] role edge
 end --A_bpmnEdge_diagramElement_target

  --DiagramElement_BPMNEdge
 association A_bpmnEdge_diagramElement_source between
	DiagramElement [0..1] role diagramElement_source
	BPMNEdge [0..*] role edge_a
 end --A_bpmnEdge_diagramElement_source

  --BPMNLabelStyle_BPMNLabel
 association A_bpmnLabel_bpmnLabelStyle between
	BPMNLabelStyle [0..1] role labelStyle
	BPMNLabel [0..*] role labell
 end --A_bpmnLabel_bpmnLabelStyle

  --BaseElement_BPMNPlane
 association A_bpmnPlane_BaseElement between
	BaseElement [0..1] role baseElement
	BPMNPlane [0..*] role plane
 end --A_bpmnPlane_BaseElement

  --BaseElement_BPMNShape
 association A_bpmnShape_BaseElement between
	BaseElement [0..1] role baseElement
	BPMNShape [0..*] role shape
 end --A_bpmnShape_BaseElement

  --BPMNShape_BPMNShape
 association A_bpmnShape_bpmnShape between
	BPMNShape [1] role participantBandKind
	BPMNShape [0..1] role choreographyActivityShape
 end --A_bpmnShape_bpmnShape

  --ChoreographyActivity_CorrelationKey
 composition A_correlationKeys_choreographyActivity between
	ChoreographyActivity [0..1] role choreographyActivity
	CorrelationKey [0..*] role correlationKeys
 end --A_correlationKeys_choreographyActivity

  --ChoreographyActivity_Participant
 association A_participantRefs_choreographyActivity between
	ChoreographyActivity [0..*] role choreographyActivity_a
	Participant [2..*] role participantRefs
 end --A_participantRefs_choreographyActivity

  --Participant_ChoreographyActivity
 association A_initiatingParticipantRef_choreographyActivity between
	Participant [1] role initiatingParticipantRef
	ChoreographyActivity [0..*] role choreographyActivity
 end --A_initiatingParticipantRef_choreographyActivity

  --ChoreographyTask_MessageFlow
 association A_messageFlowRef_choreographyTask between
	ChoreographyTask [0..1] role choreographyTask
	MessageFlow [1..2] role messageFlowRef
 end --A_messageFlowRef_choreographyTask

  --Choreography_CallChoreography
 association A_calledChoreographyRef_callChoreographyActivity between
	Choreography [0..1] role calledChoreographyRef
	CallChoreography [0..*] role callChoreographyActivity
 end --A_calledChoreographyRef_callChoreographyActivity

  --CallChoreography_ParticipantAssociation
 composition A_participantAssociations_callChoreographyActivity between
	CallChoreography [0..1] role callChoreographyActivity
	ParticipantAssociation [0..*] role participantAssociations
 end --A_participantAssociations_callChoreographyActivity

  --MessageFlow_MessageFlowAssociation
 association A_outerMessageFlowRef_messageFlowAssociation between
	MessageFlow [1] role outerMessageFlowRef
	MessageFlowAssociation [0..*] role messageFlowAssociation_a
 end --A_outerMessageFlowRef_messageFlowAssociation

  --MessageFlow_MessageFlowAssociation
 association A_innerMessageFlowRef_messageFlowAssociation between
	MessageFlow [1] role innerMessageFlowRef
	MessageFlowAssociation [0..*] role messageFlowAssociation
 end --A_innerMessageFlowRef_messageFlowAssociation

  --Participant_ParticipantAssociation
 association A_outerParticipantRef_participantAssociation between
	Participant [1] role outerParticipantRef
	ParticipantAssociation [0..*] role participantAssociation_a
 end --A_outerParticipantRef_participantAssociation

  --Participant_ParticipantAssociation
 association A_innerParticipantRef_participantAssociation between
	Participant [1] role innerParticipantRef
	ParticipantAssociation [0..*] role participantAssociation
 end --A_innerParticipantRef_participantAssociation

  --Collaboration_ConversationAssociation 
 composition A_conversationAssociations_converstaionAssociations between
	Collaboration [0..1] role converstaionAssociations
	ConversationAssociation [0..1] role conversationAssociations -- **** CHANGED cardinality altered from 1 to 0..1
 end --A_conversationAssociations_converstaionAssociations

  --Collaboration_ParticipantAssociation
 composition A_participantAssociations_collaboration between
	Collaboration [0..1] role collaboration
	ParticipantAssociation [0..*] role participantAssociations
 end --A_participantAssociations_collaboration

  --Collaboration_MessageFlowAssociation
 composition A_messageFlowAssociations_collaboration between
	Collaboration [0..1] role collaboration
	MessageFlowAssociation [0..*] role messageFlowAssociations
 end --A_messageFlowAssociations_collaboration

  --Collaboration_CorrelationKey
 composition A_correlationKeys_collaboration between
	Collaboration [0..1] role collaboration
	CorrelationKey [0..*] role correlationKeys
 end --A_correlationKeys_collaboration

  --Collaboration_ConversationLink
 composition A_conversationLinks_collaboration between
	Collaboration [0..1] role collaboration
	ConversationLink [0..*] role conversationLinks
 end --A_conversationLinks_collaboration

  --Collaboration_ConversationNode
 composition A_conversations_collaboration between
	Collaboration [0..1] role collaboration
	ConversationNode [0..*] role conversations
 end --A_conversations_collaboration

  --InteractionNode_MessageFlow
 association A_sourceRef_messageFlow between
	InteractionNode [1] role sourceRef
	MessageFlow [0..*] role messageFlow
 end --A_sourceRef_messageFlow

  --InteractionNode_MessageFlow
 association A_targetRef_messageFlow between
	InteractionNode [1] role targetRef
	MessageFlow [0..*] role messageFlow_a
 end --A_targetRef_messageFlow

  --Participant_ParticipantMultiplicity
 composition A_participantMultiplicity_participant between
	Participant [0..1] role participant
	ParticipantMultiplicity [0..1] role participantMultiplicity
 end --A_participantMultiplicity_participant

  --InteractionNode_ConversationLink
 association A_targetRef_incomingConversationLinks between
	InteractionNode [1] role targetRef
	ConversationLink [0..*] role incomingConversationLinks
 end --A_targetRef_incomingConversationLinks

  --InteractionNode_ConversationLink
 association A_sourceRef_outgoingConversationLinks between
	InteractionNode [1] role sourceRef
	ConversationLink [0..*] role outgoingConversationLinks
 end --A_sourceRef_outgoingConversationLinks

  --SubConversation_ConversationNode
 composition A_conversationNodes_subConversation between
	SubConversation [0..1] role subConversation
	ConversationNode [0..*] role conversationNodes
 end --A_conversationNodes_subConversation

  --ConversationNode_ConversationAssociation
 association A_outerConversationNodeRef_conversationAssociation between
	ConversationNode [0..*] role outerConversationNodeRef
	ConversationAssociation [0..*] role conversationAssociation_a
 end --A_outerConversationNodeRef_conversationAssociation

  --ConversationAssociation_ConversationNode
 association A_innerConversationNodeRef_conversationAssociation between
	ConversationAssociation [0..*] role conversationAssociation
	ConversationNode [0..*] role innerConversationNodeRef
 end --A_innerConversationNodeRef_conversationAssociation

  --ConversationNode_CorrelationKey
 composition A_correlationKeys_conversationNode between
	ConversationNode [0..1] role conversationNode
	CorrelationKey [0..*] role correlationKeys
 end --A_correlationKeys_conversationNode

  --CallConversation_ParticipantAssociation
 composition A_participantAssociations_callConversation between
	CallConversation [0..1] role callConversation
	ParticipantAssociation [0..*] role participantAssociations
 end --A_participantAssociations_callConversation

  --ConversationNode_MessageFlow
 association A_messageFlowRefs_communication between
	ConversationNode [0..*] role communication
	MessageFlow [0..*] role messageFlowRefs
 end --A_messageFlowRefs_communication

  --Participant_ConversationNode
 association A_participantRefs_conversationNode between
	Participant [2..*] role participantRefs
	ConversationNode [0..*] role conversationNode
 end --A_participantRefs_conversationNode

  --Collaboration_CallConversation
 association A_calledCollaborationRef_callConversation between
	Collaboration [0..1] role calledCollaborationRef
	CallConversation [0..*] role callConversation
 end --A_calledCollaborationRef_callConversation

  --Participant_PartnerRole
 association A_partnerRoleRef_participantRef between
	Participant [0..*] role participantRef
	PartnerRole [0..*] role partnerRoleRef
 end --A_partnerRoleRef_participantRef

  --Participant_PartnerEntity
 association A_partnerEntityRef_participantRef between
	Participant [0..*] role participantRef
	PartnerEntity [0..*] role partnerEntityRef
 end --A_partnerEntityRef_participantRef

  --EndPoint_Participant
 association A_endPointRefs_participant between
	EndPoint [0..*] role endPointRefs
	Participant [0..*] role participant
 end --A_endPointRefs_participant

  --ItemDefinition_Message
 association A_itemRef_message between
	ItemDefinition [0..1] role itemRef
	Message [0..*] role message
 end --A_itemRef_message

  --ItemDefinition_CorrelationProperty
 association A_type_correlationProperty between
	ItemDefinition [0..1] role type
	CorrelationProperty [0..*] role correlationProperty
 end --A_type_correlationProperty

  --CorrelationSubscription_CorrelationPropertyBinding
 composition A_correlationPropertyBinding_correlationSubscription between
	CorrelationSubscription [0..1] role correlationSubscription
	CorrelationPropertyBinding [0..*] role correlationPropertyBinding
 end --A_correlationPropertyBinding_correlationSubscription

  --CorrelationSubscription_CorrelationKey
 association A_correlationKeyRef_correlationSubscription between
	CorrelationSubscription [0..*] role correlationSubscription
	CorrelationKey [0..*] role correlationKeyRef
 end --A_correlationKeyRef_correlationSubscription

  --CorrelationPropertyBinding_CorrelationProperty
 association A_correlationPropertyRef_correlationPropertyBinding between
	CorrelationPropertyBinding [0..*] role correlationPropertyBinding
	CorrelationProperty [0..*] role correlationPropertyRef
 end --A_correlationPropertyRef_correlationPropertyBinding

  --CorrelationPropertyBinding_FormalExpression
 composition A_dataPath_correlationPropertyBinding between
	CorrelationPropertyBinding [0..1] role correlationPropertyBinding
	FormalExpression [0..*] role dataPath
 end --A_dataPath_correlationPropertyBinding

  --CorrelationPropertyRetrievalExpression_Message
 association A_messageRef_correlationPropertyRetrievalExpression between
	CorrelationPropertyRetrievalExpression [0..*] role correlationPropertyRetrievalExpression
	Message [0..*] role messageRef
 end --A_messageRef_correlationPropertyRetrievalExpression

  --CorrelationProperty_CorrelationPropertyRetrievalExpression
 composition A_correlationPropertyRetrievalExpression_correlationproperty between
	CorrelationProperty [0..1] role correlationproperty
	CorrelationPropertyRetrievalExpression [1..*] role correlationPropertyRetrievalExpression
 end --A_correlationPropertyRetrievalExpression_correlationproperty

  --ItemDefinition_FormalExpression
 association A_evaluatesToTypeRef_formalExpression between
	ItemDefinition [1] role evaluatesToTypeRef
	FormalExpression [0..*] role formalExpression
 end --A_evaluatesToTypeRef_formalExpression

  --CorrelationPropertyRetrievalExpression_FormalExpression
 composition A_messagePath_correlationset between
	CorrelationPropertyRetrievalExpression [0..1] role correlationset
	FormalExpression [0..*] role messagePath
 end --A_messagePath_correlationset

  --CorrelationKey_CorrelationProperty
 association A_correlationPropertyRef_correlationKey between
	CorrelationKey [0..*] role correlationKey
	CorrelationProperty [0..*] role correlationPropertyRef
 end --A_correlationPropertyRef_correlationKey

  --Process_CorrelationSubscription
 composition A_correlationSubscriptions_process between
	Process [0..1] role process
	CorrelationSubscription [0..*] role correlationSubscriptions
 end --A_correlationSubscriptions_process

  --ItemDefinition_Error
 association A_structureRef_error between
	ItemDefinition [0..1] role structureRef
	Error [0..*] role error
 end --A_structureRef_error

  --CallableElement_InputOutputBinding
 composition A_ioBinding_callableElement between
	CallableElement [0..1] role callableElement
	InputOutputBinding [0..*] role ioBinding
 end --A_ioBinding_callableElement

  --OutputSet_InputOutputBinding
 association A_outputDataRef_inputOutputBinding between
	OutputSet [0..*] role outputDataRef
	InputOutputBinding [0..*] role inputOutputBinding
 end --A_outputDataRef_inputOutputBinding

  --InputOutputBinding_InputSet
 association A_inputDataRef_inputOutputBinding between
	InputOutputBinding [0..*] role inputOutputBinding
	InputSet [0..*] role inputDataRef
 end --A_inputDataRef_inputOutputBinding

  --InputOutputBinding_Operation
 association A_operationRef_ioBinding between
	InputOutputBinding [0..*] role ioBinding
	Operation [0..*] role operationRef
 end --A_operationRef_ioBinding

  --FlowElement_Monitoring
 composition A_monitoring_flowElement between
	FlowElement [0..1] role flowElement
	Monitoring [0..1] role monitoring
 end --A_monitoring_flowElement

  --FlowElement_Auditing
 composition A_auditing_flowElement between
	FlowElement [0..1] role flowElement
	Auditing [0..1] role auditing
 end --A_auditing_flowElement

  --SequenceFlow_Expression
 composition A_conditionExpression_sequenceFlow between
	SequenceFlow [0..1] role sequenceFlow
	Expression [0..1] role conditionExpression
 end --A_conditionExpression_sequenceFlow

  --Import_ItemDefinition
 association A_import_itemDefinition between
	Import [0..1] role import
	ItemDefinition [0..*] role itemDefinition
 end --A_import_itemDefinition

  --Operation_MessageEventDefinition
 association A_operationRef_messageEventDefinition between
	Operation [0..1] role operationRef
	MessageEventDefinition [0..*] role messageEventDefinition
 end --A_operationRef_messageEventDefinition

  --Message_MessageEventDefinition
 association A_messageRef_messageEventDefinition between
	Message [0..1] role messageRef
	MessageEventDefinition [0..*] role messageEventDefinition
 end --A_messageRef_messageEventDefinition

  --ItemDefinition_ResourceParameter
 association A_type_resourceParameter between
	ItemDefinition [0..1] role type
	ResourceParameter [0..*] role resourceParameter
 end --A_type_resourceParameter

  --ExtensionAttributeDefinition_ExtensionAttributeValue
 association A_extensionAttributeDefinition_extensionAttributeValue between
	ExtensionAttributeDefinition [1] role extensionAttributeDefinition
	ExtensionAttributeValue [0..*] role extensionAttributeValue
 end --A_extensionAttributeDefinition_extensionAttributeValue

  --BaseElement_ExtensionAttributeValue
 composition A_extensionValues_baseElement between
	BaseElement [0..1] role baseElement
	ExtensionAttributeValue [0..*] role extensionValues
 end --A_extensionValues_baseElement

  --ExtensionDefinition_ExtensionAttributeDefinition
 composition A_extensionAttributeDefinitions_extensionDefinition between
	ExtensionDefinition [1..1] role extensionDefinition
	ExtensionAttributeDefinition [0..*] role extensionAttributeDefinitions
 end --A_extensionAttributeDefinitions_extensionDefinition

  --Extension_ExtensionDefinition
 composition A_definition_extension between
	Extension [0..1] role extension
	ExtensionDefinition [1] role definition
 end --A_definition_extension

  --BaseElement_ExtensionDefinition
 association A_extensionDefinitions_baseElement between
	BaseElement [0..*] role baseElement
	ExtensionDefinition [0..*] role extensionDefinitions
 end --A_extensionDefinitions_baseElement

  --Element_ExtensionAttributeValue
 association A_extensionAttributeValue_element between
	Element [0..1] role valueRef
	ExtensionAttributeValue [*] role extensionAttributeValue
 end --A_extensionAttributeValue_element

  --Element_Relationship
 association A_relationship_element_target between
	Element [1..*] role targets
	Relationship [0..*] role relationship_b
 end --A_relationship_element_target

  --Element_Relationship
 association A_relationship_element_source between
	Element [1..*] role sources
	Relationship [0..*] role relationship_a
 end --A_relationship_element_source

  --Operation_Error
 association A_errorRefs_operation between
	Operation [0..*] role operation
	Error [0..*] role errorRefs
 end --A_errorRefs_operation

  --Assignment_Expression
 composition A_to_assignment between
	Assignment [0..1] role assignment
	Expression [1] role to
 end --A_to_assignment

  --Assignment_Expression
 composition A_from_assignment between
	Assignment [0..1] role assignment_a
	Expression [1] role from_a
 end --A_from_assignment

  --ItemDefinition_ItemAwareElement
 association A_itemSubjectRef_itemAwareElement between
	ItemDefinition [0..1] role itemSubjectRef
	ItemAwareElement [0..*] role itemAwareElement
 end --A_itemSubjectRef_itemAwareElement

  --DataAssociation_Assignment
 composition A_assignment_dataAssociation between
	DataAssociation [0..1] role dataAssociation
	Assignment [0..*] role assignment
 end --A_assignment_dataAssociation

  --DataAssociation_FormalExpression
 composition A_transformation_dataAssociation between
	DataAssociation [0..1] role dataAssociation
	FormalExpression [0..1] role transformation
 end --A_transformation_dataAssociation

  --ItemAwareElement_DataAssociation
 association A_targetRef_dataAssociation between
	ItemAwareElement [1] role targetRef
	DataAssociation [0..*] role dataAssociation
 end --A_targetRef_dataAssociation

 
  --DataAssociation_ItemAwareElement
  -- BUG?
 association A_sourceRef_dataAssociation between
	ItemAwareElement [1] role sourceRef
	DataAssociation [0..*] role dataAssociation_a
 end --A_sourceRef_dataAssociation

  --ItemAwareElement_DataState
 composition A_dataState_itemAwareElement between
	ItemAwareElement [0..1] role itemAwareElement
	DataState [0..1] role dataState
 end --A_dataState_itemAwareElement

  --ThrowEvent_InputSet
 composition A_inputSet_throwEvent between
	ThrowEvent [0..1] role throwEvent
	InputSet [0..1] role inputSet
 end --A_inputSet_throwEvent

  --ThrowEvent_DataInputAssociation
 composition A_dataInputAssociation_throwEvent between
	ThrowEvent [0..1] role throwEvent
	DataInputAssociation [0..*] role dataInputAssociation
 end --A_dataInputAssociation_throwEvent

  --DataObject_DataObjectReference
 association A_dataObjectRef_dataObject between
	DataObject [1] role dataObjectRef
	DataObjectReference [0..*] role dataObject
 end --A_dataObjectRef_dataObject

  --DataStore_DataStoreReference
 association A_dataStoreRef_dataStoreReference between
	DataStore [0..1] role dataStoreRef
	DataStoreReference [0..*] role dataStoreReference
 end --A_dataStoreRef_dataStoreReference

  --Event_Property
 composition A_properties_event between
	Event [0..1] role event
	Property [0..*] role properties
 end --A_properties_event

  --Process_Property
 composition A_properties_process between
	Process [0..1] role process
	Property [0..*] role properties
 end --A_properties_process

  --Activity_CompensateEventDefinition
 association A_activityRef_compensateEventDefinition between
	Activity [0..1] role activityRef
	CompensateEventDefinition [0..*] role compensateEventDefinition
 end --A_activityRef_compensateEventDefinition

  --ConditionalEventDefinition_Expression
 composition A_condition_conditionalEventDefinition between
	ConditionalEventDefinition [0..1] role conditionalEventDefinition
	Expression [1] role condition
 end --A_condition_conditionalEventDefinition

  --Error_ErrorEventDefinition
 association A_errorRef_errorEventDefinition between
	Error [0..1] role errorRef
	ErrorEventDefinition [0..*] role errorEventDefinition
 end --A_errorRef_errorEventDefinition

  --ItemDefinition_Escalation
 association A_structureRef_escalation between
	ItemDefinition [0..1] role structureRef
	Escalation [0..*] role escalation
 end --A_structureRef_escalation

  --Escalation_ErrorEventDefinition
 association A_errorEventDefinition_escalation between
	Escalation [0..1] role escalationRef
	ErrorEventDefinition [0..*] 
 end --A_errorEventDefinition_escalation

  --Escalation_EscalationEventDefinition
 association A_escalationRef_escalationEventDefinition between
	Escalation [0..1] role escalationRef
	EscalationEventDefinition [0..*] role escalationEventDefinition
 end --A_escalationRef_escalationEventDefinition

  --CatchEvent_DataOutput
 composition A_dataOutputs_catchEvent between
	CatchEvent [0..1] role catchEvent
	DataOutput [0..*] role dataOutputs
 end --A_dataOutputs_catchEvent

  --CatchEvent_EventDefinition
 composition A_eventDefinitions_catchEvent between
	CatchEvent [0..1] role catchEvent
	EventDefinition [0..*] role eventDefinitions
 end --A_eventDefinitions_catchEvent

  --EventDefinition_CatchEvent
 association A_eventDefinitionRefs_catchEvent between
	EventDefinition [0..*] role eventDefinitionRefs
	CatchEvent [0..*] role catchEvent_a
 end --A_eventDefinitionRefs_catchEvent

  --CatchEvent_OutputSet
 composition A_outputSet_catchEvent between
	CatchEvent [0..1] role catchEvent
	OutputSet [0..1] role outputSet
 end --A_outputSet_catchEvent

  --CatchEvent_DataOutputAssociation
 composition A_dataOutputAssociation_catchEvent between
	CatchEvent [0..1] role catchEvent
	DataOutputAssociation [0..*] role dataOutputAssociation
 end --A_dataOutputAssociation_catchEvent

  --TimerEventDefinition_Expression
 composition A_timeDuration_timerEventDefinition between
	TimerEventDefinition [0..1] role timerEventDefinition
	Expression [0..1] role timeDuration
 end --A_timeDuration_timerEventDefinition

  --LinkEventDefinition_LinkEventDefinition
 association A_target_source between
	LinkEventDefinition [0..1] role target
	LinkEventDefinition [0..*] role source
 end --A_target_source

  --TimerEventDefinition_Expression
 composition A_timeCycle_timerEventDefinition between
	TimerEventDefinition [0..1] role timerEventDefinition_b
	Expression [0..1] role timeCycle
 end --A_timeCycle_timerEventDefinition

  --TimerEventDefinition_Expression
 composition A_timeDate_timerEventDefinition between
	TimerEventDefinition [0..1] role timerEventDefinition_a
	Expression [0..1] role timeDate
 end --A_timeDate_timerEventDefinition

  --Signal_SignalEventDefinition
 association A_signalRef_signalEventDefinition between
	Signal [0..1] role signalRef
	SignalEventDefinition [0..*] role signalEventDefinition
 end --A_signalRef_signalEventDefinition

  --ItemDefinition_Signal
 association A_structureRef_signal between
	ItemDefinition [0..1] role structureRef
	Signal [0..*] role signal
 end --A_structureRef_signal

  --SequenceFlow_ComplexGateway
 association A_default_complexGateway between
	SequenceFlow [0..1] role default
	ComplexGateway [0..*] role complexGateway
 end --A_default_complexGateway

  --ComplexGateway_Expression
 composition A_activationCondition_complexGateway between
	ComplexGateway [0..1] role complexGateway
	Expression [0..1] role activationCondition
 end --A_activationCondition_complexGateway

  --SequenceFlow_ExclusiveGateway
 association A_default_exclusiveGateway between
	SequenceFlow [0..1] role default
	ExclusiveGateway [0..*] role exclusiveGateway
 end --A_default_exclusiveGateway

  --SequenceFlow_InclusiveGateway
 association A_default_inclusiveGateway between
	SequenceFlow [0..1] role default
	InclusiveGateway [0..*] role inclusiveGateway
 end --A_default_inclusiveGateway

  --UserTask_Rendering
 composition A_renderings_usertask between
	UserTask [0..1] role usertask
	Rendering [0..*] role renderings
 end --A_renderings_usertask

  --Process_Auditing
 composition A_auditing_process between
	Process [0..1] role process
	Auditing [0..1] role auditing
 end --A_auditing_process

  --GlobalUserTask_Rendering
 composition A_renderings_globalUserTask between
	GlobalUserTask [0..1] role globalUserTask
	Rendering [0..*] role renderings
 end --A_renderings_globalUserTask

  --GlobalTask_ResourceRole
 composition A_resources_globalTask between
	GlobalTask [0..1] role globalTask
	ResourceRole [0..*] role resources
 end --A_resources_globalTask

  --Lane_LaneSet
 association A_childLaneSet_parentLane between
	Lane [0..1] role parentLane
	LaneSet [0..1] role childLaneSet
 end --A_childLaneSet_parentLane

  --LaneSet_Lane
 composition A_lanes_laneSet between
	LaneSet [0..1] role laneSet
	Lane [0..*] role lanes
 end --A_lanes_laneSet

  --BaseElement_Lane
 association A_partitionElementRef_lane between
	BaseElement [0..1] role partitionElementRef
	Lane [0..*] role lane_a
 end --A_partitionElementRef_lane

  --Lane_FlowNode
 association A_flowNodeRefs_lanes between
	Lane [0..*] role lanes
	FlowNode [0..*] role flowNodeRefs
 end --A_flowNodeRefs_lanes

  --Lane_BaseElement
 composition A_partitionElement_lane between
	Lane [0..1] role lane
	BaseElement [0..1] role partitionElement
 end --A_partitionElement_lane

  --Process_Monitoring
 composition A_monitoring_process between
	Process [0..1] role process
	Monitoring [0..1] role monitoring
 end --A_monitoring_process

------------------------------------------------------------------------
constraints
------------------------------------------------------------------------
-------------------------------------------------------------------------------------	
 context Collaboration 
--------------------------------------------------------------------------------------

@aCollaborationCanOnlyHaveOneInplicitProcess(type="S", origin="BPMN2 Specification, 2017, pp.112, OMG", msg="Only one implicit pool can exist in the collaboration!")
	inv aCollaborationCanOnlyHaveOneInplicitProcess:
	-- In a process diagram which does not show a pool, the entire process is 
	-- contained in an invisible, implicit pool.
	-- A collaboration diagram may not contain more than one implicit pool.
	
		totalNumberProcessesInCollaboration() - totalNumberPoolsInCollaboration() <= 1
		
-------------------------------------------------------------------------------------	
	context Activity
--------------------------------------------------------------------------------------
	
	inv multipleExitsActivityMustHaveConditions:
	-- If an activity has got various exits, the sequence flows leaving the 
	-- activity should be provided with conditions. The completion of an activity 
	-- activates those sequence flows that have true conditions.
	-- However, normal and conditional sequence flows can leave an activity together. 
	-- In this case, each sequence flow without condition diamond generates a token  
	-- the others only if their conditions are true. In this case, however, 
	-- none of the exits should be marked as default flow, because it would 
	-- never be selected, since there are other exits that always generate a token.

	-- If an exclusive split is modeled with conditional sequence flows after 
	-- an activity, exactly one path must be selected. If the conditions at the 
	-- sequence flows are not mutually exclusive, this is a clear modeling mistake. 
	-- It is also a mistake if there are cases in which no condition becomes true.
	
	outgoingSequenceFlowsHaveConditions()


	inv compensationActivityNoIncomingAndOutgoing:
	-- A Compensation Activity must not have any incoming or outgoing Sequence Flow
	-- and Only one Compensation Activity can be associated with the Compensation 
	-- Intermediate Event
	isForCompensation() implies 
		(hasNoIncomingAndOutgoingSequenceFlow() and
	 		self.incoming.sourceRef.outgoing.targetRef->size() = 1)

	
	inv mustHaveIncomingSequenceFlow:
	-- When Start and End Events are used, a Task or Collapsed Sub-Process 
	-- must have incoming Sequence Flow unless it is a Compensation Activity.
	self.container.hasExplicitStartAndEndEvents() implies self.hasInputSequenceFlows()
	
	
-------------------------------------------------------------------------------------	
	context ReceiveTask
--------------------------------------------------------------------------------------

	inv mustNotHaveOutgoingMessageFlow:
	-- A Receive Task must not have an outgoing Message Flow
		not self.hasOutputMessageFlows()

	  inv bp_hasIncomingMessageFlow:
		-- A Receive task should have an incoming message flow
    self.hasInputMessageFlows()


-------------------------------------------------------------------------------------	
	context SendTask
--------------------------------------------------------------------------------------


	inv mustNotHaveIncomingMessageFlow:
	-- A Send Task MUST NOT have an incoming Message Flow
		not self.hasInputMessageFlows()

  inv bp_hasOutgoingMessageFlow:
	--	A Send Task should have an outgoing Message Flow
    self.hasOutputMessageFlows()



-------------------------------------------------------------------------------------	
	context ScriptTask
--------------------------------------------------------------------------------------

	inv mustNotHaveIncomingOutgoingMessageFlow:
	-- A Script Task must not have an incoming or an outgoing Message Flow
		not self.hasInputMessageFlows() and
		not self.hasOutputMessageFlows()

-------------------------------------------------------------------------------------	
	context ManualTask
--------------------------------------------------------------------------------------

	inv mustNotHaveIncomingOutgoingMessageFlow:
	-- A Manual Task must not have an incoming or an outgoing Message Flow
		not self.hasInputMessageFlows() and
		not self.hasOutputMessageFlows()

	--*****************
	inv multipleIncomingInActivityMustHaveConditions:
	-- if several non-exclusive paths end in one activity, this activity will 
	-- be carried out several times. So the joining of non-exclusive paths, 
	-- cannot be modeled without a gateway. (Otherwise the activity will be 
	-- performed once for each incoming sequence flow.) 
	
	incomingSequenceFlowsFromExclusivePaths()  
	

-------------------------------------------------------------------------------------	
	context FlowNode
--------------------------------------------------------------------------------------

	inv exclusivePathsMergingIntermediateByGateway:
	-- Merging exclusive paths require a gateway as mediator, if another gateway 
	-- or an event follows.
	-- A gateway is required if a split directly follows another gateway
		isMediadorAGateway()
	
	inv mandatoryIncomingAndOutgoingSequenceFlow:
	-- if the container includes start and end events, all flow objects must have [1] (page ???):
	-- an incoming sequence flow. Exceptions are: Start Events, Boundary Events, and Compensation Activities;
	-- an outgoing sequence flow,. Exceptions are:  End Events and Compensation Activities.
    hasIncomingAndOutgoingSequenceFlow()

  inv bp_useDefaultCondition:
	-- Use a Default Condition when using Conditional Sequence Flow
	-- TO DO
    existsDefaultCondition()

	
-------------------------------------------------------------------------------------	
	context Event
--------------------------------------------------------------------------------------
		inv bp_splitingEventShouldNotOccurAndOneTargetIsNeeded:
-- A gateway or activity is required if a split is needed after an intermediate event
-- An  event (not EndEvent or StartEvent) not target to a FlowElementsContainer must have
-- only one outgoing sequence flow and one target flow node
	isNotSplitAndHasOneTarget()
	

-------------------------------------------------------------------------------------	
	context FlowElementsContainer
--------------------------------------------------------------------------------------
	
	inv explicitStartEvRequiresNoActivOrGatWithoutInSeqFlow:
	-- If there is at least one explicit start event in a process (subprocess), there must not 
	-- be any activities or gateway without incoming sequence flow.
			explicitStartWithoutNodesWithIncomingSequenceFlow()
	
	inv explicitNodeWithoutIncSeqFlowRequiresNoStartEv:
	-- When a container (Process or Sub-Process) is modeled with an
	-- activity without in-coming sequence flow, it means that it has an
	-- implicit Start Event. Therefore explicit Start Events are not allowed
	-- (page ???).
			existsOnlyImplicitStartEvent()


	inv bp_gatewayWithSeveralInputsAndSeveralOutputs:
	-- Best-Practice
	-- A gateway with several inputs and several outputs at the same time may cause 
	-- misunderstandings and should be avoided.
	noGatewayWithSeveralInputsAndSeveralOutputs()
	
	inv bp_useExplicitStartAndEndEvents:
	-- Best-Practice
	-- It is advisable to use explicit start and end events.
	existsExplicitStartAndEndEvents()
	
	inv implicitStartEventsRequiresImplicitEndEvents:
	-- Implicit start events require implicit end events, and vice versa.
	-- In this case, all activities, gateways, etc. without outgoing sequence 
	-- flows have implicit end events. These have the same behavior as normal 
	-- untyped end events.
		noStartOrEndEvents()


	inv implicitStartAndEndEventsRequiresSurrogateActivitiesOrGateways:
	-- A process may either have only implicit or only explicit end events. 
	-- A mixture of both is not allowed. 
	existsImplicitStartAndEndEvents()

			
		inv intermediateEventsMustHaveIncAndOutSeqFlow:
	-- An intermediate event has incoming and outgoing sequence flows. 
		intermediateEventsHaveIncAndOutSeqFlows()
	
		inv startEventsHaveNoIncomingSequenceFlow:
	-- A start event has no incoming sequence flow (page 238). 
	self.totalContainerStartEvents()
					->forAll(numberInputSequenceFlows() = 0)
	
		inv endEventsHaveNoOutgoingSequenceFlow:
	-- An end event has only one incoming and no outgoing sequence flow (page 246). 
	self.totalContainerEndEvents()
				->forAll(numberOutputSequenceFlows() = 0)

	
	inv nonInterruptingStartEventsHostedOnlyByEventSubProcess:
	-- The non-interrupting variants of the events (message, conditional, escalation,
	-- timer, signal, multiple, and parallel multiple events) are only possible 
	-- within an event sub-process, but not in a normal process.
		nonInterruptingStartEventsOnlyInEventSubProcess()
	
	
	inv compensationActivityMustBeCalled:
	-- When activities that are not part of a transaction have compensation
	-- activities, these compensations must be explicitly called with a
	-- labeled or unlabeled throwing compensation event, because they cannot
	-- be triggered by aborting a transaction.
	isCompensationActivityPartOfNonTransaction()
	
	
	inv throwingCompensationEventMatchOneOfActivitiesToBeCancelled:
	-- The name of a throwing intermediate compensation event must match to 
	-- the name of one of the activities that can be cancelled.
	nameOfThrowingCompensationEventMatchNameOfCancelledActivity()
	
	inv namesOfCatchAndThrowLinkEventMustMatch:
	-- A pair of Link Events is used. The name of a throw Link Event must 
	-- match one target Link Event in the same container (Process or SubProcess) 
	-- (page 268). 
	matchInNamesOfCatchAndThrowLinkEvent()
	
		inv nameOfCatchLinkEventsMustBeUnique:
	-- There can be multiple source Link Events, but there can only be one target 
	-- Link Event (page 253). 
	nameOfCatchLinkEventsIsUnique()

	inv mandatoryIncomingOrOutgoingSequenceFlow:
	-- It is not allowed to have isolated Flow Nodes, so they must have
	-- one incoming or one outgoing sequence flow (page ???).
	hasIncomingOrOutgoingSequenceFlow()


  inv bp_limitOfFlowNodesPerDiagram:
  -- Use only 7± 2 Flow Nodes per diagram
  -- TO DO
  withinLimitOfFlowNodesPerDiagram()

  inv bp_useSendReceiveTaskOrThrowCatchMesInterEvents:
  -- Use Send/Receive Task or Throw/Catch Message Intermediate Events (not both)
  -- TO DO
  isSendReceiveTaskExclusivedUse()

  inv bp_useOnlyOneStartEvent:
  -- It is recommended that only one Start Event be used
  -- TO DO
    existsOnlyOneStartEvent()

  inv bp_unnamedSequenceFlow:
  -- An Exclusive or Event Gateway should have at most one unnamed outgoing Sequence Flow
  -- TO DO
    noMoreThanOneUnnamedSequenceFlow()

  inv bp_noUnnamedSequenceFlow:
  -- An Inclusive Gateway should have all outgoing Sequence Flow named 
  -- TO DO
    notExistsUnnamedSequenceFlow()

  inv bp_matchEndEventToGatewayName:
  -- If a SubProcess is followed by a yes/no Gateway, at least one End Event 
  -- of the SubProcess should be named to match the Gateway name 
  -- TO DO
    matchEndEventAndGatewayName()

  inv bp_activitiesMustBeName:
	-- Activities should be named
  -- TO DO
    isActivityNamed()

  inv bp_subProcessHasMoreThanOneEndEvent:
	-- If a SubProcess is followed by a Gateway labeled as a question, 
	-- it must have more than one End Event
  -- TO DO
    hasMoreThanOneEndEvent()

-------------------------------------------------------------------------------------	
	context Gateway
--------------------------------------------------------------------------------------
	inv multipleExitsDataBasedExclusiveGatewayMustHaveConditions:
	-- In a data-based exclusive gateway, the exits of an event-based exclusive 
	-- gateway must have conditions or, alternatively, if the exits of the event-based 
	-- exclusive gateway have no conditions, the first element in each outgoing 
	-- sequence flow must be a catching intermediate event. Such kind of events 
	-- can also be replaced by a receive" activity. 
	dataBasedExclusiveGatewayHasConditions()
	
	
	inv mergingExclusiveGatewayIsPrecededBySplitWithExclusiveGateway:
	-- For merging exclusive or parallel sequence flows, originated from previous 
	-- splitting, the respective gateway (exclusive or parallel gateways) should be 
	-- used.
	-- (An inclusive gateway can, in principle, also be used for the merging of 
	-- sequence flows originating from splitting, exclusive or parallel gateways. 
	-- But this is not a good modeling style. The use of an inclusive gateway
	-- for merging sequence flows that were created by a combination of
	-- various types of gateways, produce a more compact representation.)
	-- This invariant checks whether the previous flow node is an exclusive one
	(self.isJoin() and self.oclIsTypeOf(ExclusiveGateway)) implies 
			precedentSplitElementIsExclusive()
	
	inv mergingParallelGwayIsPrecededBySplitWithParallelGway:
	-- Regardless whether the parallel paths have been created by a parallel 
	-- gateway or by multiple exits of an activity, they must be joined by 
	-- a parallel (preferable) or an inclusive gateway.
	(self.isJoin() and self.oclIsTypeOf(ParallelGateway)) implies 
			precedentSplitElementIsNonExclusive()
	
--	inv mustBePartOfAContainer:
	
--	inv incomingSeqFlowsExclusiveGatewayAreExclusive:
--	-- This invariant checks whether the previous flow node is an exclusive one
--(self.isJoin() and self.oclIsTypeOf(ExclusiveGateway)) implies 
--	self.inputSequenceFlows()->forAll(isExclusive() and not isNonExclusive())
--	

	inv mergingExclusiveGatewayExclusiveTokens:
	-- If an exclusive gateway is used for merging, it must be ensured that every 
	-- time only one entrance receives a token. This can be achieved by modeling 
	-- the preceding split with an exclusive gateway, too. If an exclusive gateway 
	-- is used, exactly only one sequence flow would be selected in every case. 
	-- Alternatively it can be the result of a sequence flow loop.
		hasMergingExclusiveGatewayExclusiveTokens()

	inv mergeOrFork:
	-- A Gateway must have either multiple incoming Sequence Flow or multiple outgoing 
	-- Sequence Flow (i.e., it must merge or split the flow).
	self.isJoin() or isSplit()


	inv converging:
	-- A Gateway with a gatewayDirection of converging must have multiple incoming 
	-- Sequence Flow, but must not have multiple outgoing Sequence Flow
		self.gatewayDirection = GatewayDirection::Converging implies
				(self.numberInputSequenceFlows() > 1 and
				self.numberOutputSequenceFlows() <= 1)

	inv diverging:
	-- A Gateway with a gatewayDirection of converging must have multiple incoming 
	-- Sequence Flow, but must not have multiple outgoing Sequence Flow
		self.gatewayDirection = GatewayDirection::Diverging implies
				(self.numberOutputSequenceFlows()  > 1 and
				 self.numberInputSequenceFlows() <= 1)

-------------------------------------------------------------------------------------	
	context ExclusiveGateway
--------------------------------------------------------------------------------------
		inv bp_useDefaultCondition:
 		-- Use a Default Condition at an Exclusive Gateway
 		-- TO DO
    existsDefaultCondition()

-------------------------------------------------------------------------------------	
	context InclusiveGateway
--------------------------------------------------------------------------------------
		inv bp_useDefaultCondition:
 		-- Use a Default Condition at an Inclusive  Gateway
 		-- TO DO
    existsDefaultCondition()
    
  inv bp_matchMergingAndSplitting:
  -- create models where a merging Inclusive Gateway follows a splitting 
  -- Inclusive Gateway and that the number of Sequence Flow matches between them
 		-- TO DO
    isMergingAndSplittingMatching()



-------------------------------------------------------------------------------------	
	context ParallelGateway 
--------------------------------------------------------------------------------------
		inv bp_preventDeadlock:
 		-- Ensure that the number of incoming Sequence Flow is correct for a Parallel Gateway
 		-- TO DO
    notDeadlock()

  inv bp_matchMergingAndSplitting:
  -- Match merging and splitting Sequence Flow in Parallel Gateways 
  -- (if the desired behavior is to merge them again)
 		-- TO DO
    isMergingAndSplittingMatching()


-------------------------------------------------------------------------------------	
	context EventBasedGateway
--------------------------------------------------------------------------------------
		inv moreThanTwoSequenceFlows:
		-- An Event Gateway must have two or more outgoing Sequence Flow
		self.numberOutputSequenceFlows()  >= 2

@targetMustBeSpecific(type="W", msg="The target of the Gateways outgoing Sequence Flow must be one of the following elements: A Receive Task, an Intermediate Catch Event of type Message, Timer, Signal, Conditional or Multiple")
		inv targetMustBeSpecific:
	-- The Target of the Gateways outgoing Sequence Flow must be one of the 
	-- following elements: A Receive Task, an Intermediate Catch Event of type 
	-- Message, Timer, Signal, Conditional or Multiple.
	self.outgoing_a.targetRef
	->forAll(oclIsTypeOf(ReceiveTask) or 
			(oclIsTypeOf(IntermediateCatchEvent) 
					and (oclAsType(CatchEvent).isMessageEvent() or 
							oclAsType(CatchEvent).isTimerEvent() or 
							oclAsType(CatchEvent).isSignalEvent() or 
							oclAsType(CatchEvent).isConditionalEvent() or 
							oclAsType(CatchEvent).isMultipleEvent() )))

		inv receiveTasksWithoutBoundaryEvent:
		-- Receive Tasks used in an Event Based Gateway configuration must not 
		-- have any attached Boundary Event.
		self.outgoing_a.targetRef
			->select(oclIsTypeOf(ReceiveTask))
			->collect(oclAsType(Task).boundaryEventRefs)->isEmpty()
		
		inv receiveTasksWithoutMessageEventVV:
		-- If Message Intermediate Catch Events are used as Target for the Gateway's 
		-- outgoing Sequence Flow, then Receive Tasks must not be used and vice versa.
		(self.outgoing_a.targetRef
			->select(oclIsTypeOf(IntermediateCatchEvent))
			->collect(oclAsType(CatchEvent).isMessageEvent())->notEmpty()
		implies
		self.outgoing_a.targetRef
			->select(oclIsTypeOf(ReceiveTask))->isEmpty())
		and
		(self.outgoing_a.targetRef
			->select(oclIsTypeOf(ReceiveTask))->notEmpty()
		implies
		self.outgoing_a.targetRef
			->select(oclIsTypeOf(IntermediateCatchEvent))
			->collect(oclAsType(CatchEvent).isMessageEvent())->isEmpty())
			
		
		inv targetElementsMustHaveOnlyOneIncomingSeqFlow:
		-- Target elements in an Event Gateway configuration must not have any 
		-- additional incoming Sequence Flow (other than that from the Event Gateway).
		self.outgoing_a.targetRef->forAll(numberInputSequenceFlows() = 1)


  inv bp_useTimerIntermediateEvent:
  -- Use a Timer Intermediate Event with an Event Gateway
	-- TO DO
    existsTimerIntermediateEvent()


-------------------------------------------------------------------------------------	
	context SubProcess
--------------------------------------------------------------------------------------
	inv noMoreThanOneNoneStartEvent:
	-- A sub-process must not have more than one untyped start event. Otherwise 
	-- it is not clear where the sub-process starts after having been triggered 
	-- by the parent process.
	hasOnlyOneStartEvent()

	inv eventSubProcessesDoNotAllowUntypedStartEvent:
	-- Untyped start events, cannot be used in event sub-processes.
	triggeredByEvent = true implies totalNumberContainerNoneStartEvents() = 0

	inv onlyOneNoneStartEventInEmbeddedSubProcess:
	-- An embedded Sub-Process can only have one type of Start Event: the
	-- None Start Event (page 241).
	hasOnlyOneNoneStartEvent()

	inv eventSubProcessStartEventAllowed:
	-- Only one of a restricted type of start events (message, conditional, escalation,
	-- timer, signal, multiple, and parallel multiple events) are possible 
	-- within an event sub-process. 
		isStartEventAllowed()


	inv messageFlowConsistency:
	-- A message flow from a collapsed Subprocess is replicated in the child-level diagram.
	-- A message flow to a collapsed Subprocess is replicated in the child level diagram.
	-- An incoming message flow in child level diagram is replicated in the parent level.
	-- An outgoing message flow in child level diagram should is replicated in the parent level.
	isMessageFlowconsistent()

	inv noIncomingAndOutgoingSequenceFlow:
	-- An Event SubProcess must not have incoming or outgoing Sequence Flow
	hasNoIncomingOutgoingSequenceFlow()
			


  inv selfContainedData:
  -- A reusable SubProcess has only self-contained data 
  -- TO DO
  isDataSelfContained() 


  inv bp_matchGatewayName:
	-- If a SubProcess is followed by a yes/no gateway, at least one 
	-- end event of the SubProcess should be labeled to match the gateway label.
	-- TO DO
    matchGatewayName()

-------------------------------------------------------------------------------------	
	context DataObject
--------------------------------------------------------------------------------------
	
  inv connectedDataAssociation:
	-- A Data Object must have at least one connected Data Association
	(self.dataAssociation_a->notEmpty() or
	self.dataAssociation->notEmpty())

-------------------------------------------------------------------------------------	
	context DataObjectReference
--------------------------------------------------------------------------------------
	
  inv dataObjectAtSameContainerOrParent:
	-- Data Object References can only access Data Objects residing 
	-- in the same container or their parents
	-- TO DO
	isDataObjectAtSameContainerOrParent()

-------------------------------------------------------------------------------------	
	context DataStore 
--------------------------------------------------------------------------------------
	
  inv connectedDataAssociation:
	-- A Data Store must have at least one connected Data Association
	(self.dataAssociation_a->notEmpty() or
	self.dataAssociation->notEmpty())

	
-------------------------------------------------------------------------------------	
	context CallActivity
--------------------------------------------------------------------------------------
	inv callableElementIsReusable: 
	-- A called process itself can be a normal process. It could also be performed
	-- for itself, without being called from other process.
	-- A normal sub-process cannot be called from a different process. 
	-- A called process can have several start events. Exactly one of them should 
	-- be an untyped event. At least one must be a catching start event. 
	-- A call activity can call another process. The re-use of processes is only 
	-- possible with independent processes which are included via call activities.
	isCallable()
	
-------------------------------------------------------------------------------------	
	context CatchEvent
--------------------------------------------------------------------------------------
	inv catchingErrorEventCanOnlyBeAttachedToActivityBoundary: 
	-- Error intermediate events cannot be used within normal sequence flows. 
	-- They can only be attached to activity boundaries. 
	-- Catching error events, are always intermediate events. They can only be 
	-- attached to the boundary of tasks or sub-processes.
	-- An error intermediate event should trigger an exception flow.
	isCatchingErrorAttachedToActivityBoundary()
	
		inv catchErrorEventTriggerExceptionFlow: 
	-- An error is caught by an error intermediate event attached to 
	-- the sub-process border. The intermediate event should trigger an 
	-- exception flow.
		self.isErrorEvent() implies  
		(self.oclAsType(BoundaryEvent).attachedToRef.isDefined() and
		self.outgoing_a.targetRef->notEmpty())

		inv namedCatchingErrorEventHasThrowEventWithSameName: 
	-- A catching error reacts to thrown errors with the same label.
	-- If there is an unlabeled intermediate event catching error, it reacts to
	-- any type of error.
		catchingErrorEventNameMatchThrowEventName()

		inv catchingErrorMustNotMixNamedAndUnnamedEvents: 
	-- If there are several error intermediate events attached to a sub-process 
	-- boundary, they should be always labeled. Since an unlabeled error
	-- intermediate event always catches any type of error, it also reacts 
	-- to errors caused by labeled events. Therefore, the resulting implicit
	-- parallel flows would be difficult to understand.
		noMixNamedAndUnnamedcatchingErrorEvents()
		
		inv catchEscalationEventIsBoundaryEvent: 
	-- An escalation is caught by an escalation intermediate event attached to 
	-- the sub-process border. The intermediate event should trigger an 
	-- exception flow.
	isCatchingEscalationAttachedToActivityBoundary()

		inv catchEscalationEventTriggerExceptionFlow: 
	-- An escalation is caught by an escalation intermediate event attached to 
	-- the sub-process border. The intermediate event should trigger an 
	-- exception flow.
		self.isEscalationEvent() implies  
		(self.oclAsType(BoundaryEvent).attachedToRef.isDefined() and
		self.outgoing_a.targetRef->notEmpty())


		inv namedCatchingEscalationEventHasThrowEventWithSameName: 
	-- A catching escalation event reacts to thrown escalation events with the same label.
	-- If there is an unlabeled intermediate event catching escalation, it reacts to
	-- any type of escalation.	
		catchingEscalationEventNameMatchThrowEventName()
		
		inv interrCatchingEscalationMustNotMixNamedAndUnnamedEvents: 
	-- If there are several interrupting escalation intermediate events attached to a sub-process 
	-- boundary, they should be always labeled. Since an unlabeled escalation
	-- intermediate event always catches any type of escalation, it also reacts 
	-- to escalations caused by labeled events. Therefore, the resulting implicit
	-- parallel flows would be difficult to understand.
		noMixNamedAndUnnamedCatchingInterEscalationEvents()
		
		inv nonInterrCatchingEscalationMustNotMixNamedAndUnnamedEvents: 
	-- If there are several non-interrupting escalation intermediate events attached to a sub-process 
	-- boundary, they should be always labeled. Since an unlabeled escalation
	-- intermediate event always catches any type of escalation, it also reacts 
	-- to escalations caused by labeled events. Therefore, the resulting implicit
	-- parallel flows would be difficult to understand.
		noMixNamedAndUnnamedCatchingNonInterEscalationEvents()
		
		inv catchEscalationEventIsInterruptingEventRequiresEndEvent: 
	-- If an escalation is required to abort the entire activity, the attached 
	-- intermediate event's boundaries is an interrupting event. 
	-- In this case, the throwing escalation event in the sub-process needs to be 
	-- an end event. The throwing escalation event is caught by an escalation
	-- intermediate event with the same name, attached to the sub-process border.
	
		catchEscalationEventInterruptingEventHasEndEvent()
				
	inv catchingCompensationEventCanOnlyBeAttachedToActivityBoundary: 
	-- Catching intermediate events of the compensation type are always attached to 
	-- an activity, and they always have outgoing compensation associations running 
	-- to the compensating activity. 

	compensationEventIsAttachedToActivityBoundary()
	 
	inv catchingMessageEventHasIncomingMessageFlow: -- NOT USED
	-- A catching message intermediate event must have an incoming message flow. 
		
		self.isMessageEvent() implies (hasInputMessageFlows() or hasOutputSequenceFlows())

	inv catchingLinkEventHasOnlyOutgoingSequenceFlow: 
	-- A catching link intermediate event cannot have incoming sequence flows,
	-- and must have an outgoing  sequence flow
		
		self.isLinkEvent() implies self.hasOutputSequenceFlows() and self.withoutInputSequenceFlows()

	inv incomingMessageFlowHasMessageMultipleType: 
	-- A start event or a catching intermediate event with incoming message 
	-- flow must be of type Message of Multiple 
		self.numberInputMessageFlows() > 0 implies (self.isMessageEvent() or self.isMultipleEvent())

	inv multipleIncomingMesgFlowHasMultipleType: 
	-- A start event or a catching intermediate event with more than one incoming 
	-- message flow must be of type Multiple   
		self.numberInputMessageFlows() > 1 implies self.isMultipleEvent()

	inv outgoingMessageFlowNotAllowedMessageType: 
	-- A start event or a catching intermediate event cannot have outgoing message flows 
		self.isMessageEvent() implies self.numberOutputMessageFlows() = 0 

		inv nameOfCatchLinkEventsMustBeDefined:
	-- In order to match throw and catch Link Events, their names must be defined. 
	isNameOfCatchLinkEventsDefined()

-------------------------------------------------------------------------------------	
	context ThrowEvent
--------------------------------------------------------------------------------------
	inv errorEventIsAlwaysEndEvent: 
	-- Throwing error events are always end events, because they completely abort 
	-- the surrounding sub-process. 
	self.isErrorEvent() implies
			self.oclIsTypeOf(EndEvent)
	
	inv throwingErrorEventHasACatchErrorEventWithSameNameXORUnnamed: 
	-- Error events can be modeled in a sub-process. 
	-- A throwing error is caught by an error intermediate event with the same name,
	-- or unnamed attached to the sub-process border.
	throwErrorHasCatchEvent()

	inv escalationEventIsIntermediateOrEndEvent: 
	-- Throwing escalation events are intermediate or end events, and they can interrupt 
	-- or not the surrounding sub-process. 
	self.isEscalationEvent() implies
			(self.oclIsTypeOf(EndEvent) or self.oclIsTypeOf(IntermediateThrowEvent))
	

	inv throwingEscalationEndEventIsInterrupting: 
	-- Throwing escalation events can be modeled in a sub-process. 
	-- If an escalation is required to abort the entire activity the throwing
	-- escalation event in the sub-process needs to be an end event.
	-- An escalation is caught by an interrupting escalation intermediate event 
	-- with the same name or unnamed, attached to the sub-process border.
	isThrowingEscalationEndEventInterrupting()

	inv throwingEscalationIntermediateEventIsNonInterrupting: 
	-- Throwing escalation events can be modeled in a sub-process. 
	-- If an escalation is required not abort the entire activity, the throwing
	-- escalation event in the sub-process needs to be an intermediate event.
	-- The escalation is caught by an escalation intermediate event with the same name
	-- or unnamed, attached to the sub-process border.
	isThrowingEscalationIntermediateEventNonInterrupting()

	@existsCatchSignalEvent(type="S", origin="pp.???", msg="A Throwing Signal End Event must be caught by an Interrupting Signal Catch Event with the same name or unnamed!")
	inv existsCatchSignalEvent: 
	-- Throwing Signal events can be modeled in a process. 
	-- A throwing signal is caught by a signal intermediate event with the same name,
	-- or unnamed in the same process or another process of same collaboration.
	hasCatchSignalEvent()




	inv throwingMessageEventHasOutgoingMessageFlow: 
		-- if an element has an outgoing message flow, it is a throwing message intermediate event  
		
		hasOutputMessageFlows() implies self.isMessageEvent() 

	inv throwingLinkEventHasOnlyIncomingSequenceFlow: 
	-- A throwing link intermediate event cannot have outgoing sequence flows,
	-- and must have an incoming  sequence flow
		self.isLinkEvent() implies self.hasInputSequenceFlows() and self.withoutOutputSequenceFlows()

	inv outgoingMessageFlowHasMessageMultipleType: 
	-- A end event or a throwing intermediate event with outgoing message 
	-- flow must be of type Message of Multiple 
		self.numberOutputMessageFlows() > 0 implies (self.isMessageEvent() or self.isMultipleEvent())

	inv multipleOutgoingMesgFlowHasMultipleType: 
	-- A end event or a throwing intermediate event with more than one outgoing 
	-- message flow must be of type Multiple   
		self.numberOutputMessageFlows() > 1 implies self.isMultipleEvent()

	inv incomingMessageFlowNotAllowedMessageType: 
	-- A end event or a throwing intermediate event cannot have incoming message flows 
		self.isMessageEvent() implies self.numberInputMessageFlows() = 0 

		inv nameOfThrowLinkEventsMustBeDefined:
	-- In order to match throw and catch Link Events, their names must be defined. 
	isNameOfThrowLinkEventsDefined()

-------------------------------------------------------------------------------------	
	context StartEvent
--------------------------------------------------------------------------------------
	inv errorStartEventRestrictedToEventSubProcess: 
	-- A start event of type "error" can only be used in event sub-processes, 
	-- i.e. such an event can only trigger interrupting event sub-processes.
	
		self.isErrorEvent() implies
				(self.container.oclIsTypeOf(SubProcess) and 
				self.container.oclAsType(SubProcess).isEventSubProcess() and
				self.isInterrupting = true)
	
	inv escalationStartEventRestrictedToEventSubProcess: 
		-- In contrast to normal processes, the escalation event can be used 
		-- in event sub-processes as a starting event.
	
		self.isEscalationEvent() implies
				(self.container.oclIsTypeOf(SubProcess) and 
				self.container.oclAsType(SubProcess).isEventSubProcess())
	
	inv compensationStartEventInSubProcess: 
	-- The compensation event is an event type that can be used as a start 
	-- event in an event sub-process, but only as an interrupting event.
	
		self.isCompensateEvent() implies
				(self.container.oclIsTypeOf(SubProcess) and
				self.container.oclAsType(SubProcess).isEventSubProcess() and
				self.isInterrupting = true)
	
	inv interruptingTypesRestrictedToEventSubProcess: 
	-- The non-interrupting variants of message events,  conditional events, 
	-- timer events, signal events, multiple events, and parallel multiple events 
	-- are only possible within an event sub-process, but not in a normal process.
	isContainerEventSubProcess()

@messageStartEventHasIncomingMessageFlow(type="W", msg="A start event which is triggered from the outside of the process through an incoming message flow must be typed as message start event")
	inv messageStartEventHasIncomingMessageFlow: 
	-- A start event which is triggered from the outside of the process through 
	-- an incoming message flow must be typed as message start event.
		(self.hasInputMessageFlows() implies self.isMessageEvent()) 

		inv cannotHaveIncomingButHaveOutgoingSequenceFlow: 
	-- A start event cannot have an input sequence flow
	self.inputSequenceFlows()->isEmpty() and 
	self.outputSequenceFlows()->size() > 0

		inv topLevelProcessHasRestrictedTypeOfStartEvents:
	-- Top-level processes can have seven types of start events: none,
	-- message, timer, conditional, signal, multiple, and parallel (page
	-- 112).
	isContainerTopLevelProcess()

@eventSubProcessAllowedEventType(type="W", msg="Only some types of Start, Intermediate and End Events are allowed")
		inv eventSubProcessAllowedEventType:
		-- Only some types of Start, Intermediate and End Events are allowed 
			(self.container.oclIsKindOf(SubProcess) 
						and self.container.oclAsType(SubProcess).isEventSubProcess())
			implies
			((self.isInterruptingEvent() implies
			(not (self.isCancelEvent() or
						self.isNoneEvent() or
						self.isLinkEvent() or
						self.isTerminateEvent())))
			or
			(self.isNonInterruptingEvent() implies
			(not (self.isCancelEvent() or
						self.isNoneEvent() or
						self.isLinkEvent() or
						self.isTerminateEvent() or
						self.isErrorEvent() or
						self.isCompensateEvent()))))
						

	  inv bp_shouldHaveName:
	  -- A Start Event must have a name
		-- TO DO
    hasName()

	  inv bp_incomingMessageFlow:
	  -- A Message Start Event should have an incoming Message Flow
		-- TO DO
    hasMessageFlow()

-------------------------------------------------------------------------------------	
context BoundaryEvent
-------------------------------------------------------------------------------------	
	inv nonInterruptingEventPathMergedByAnInclusiveGateway: 
	-- An attached non-interrupting event simply creates an additional token if it 
	-- occurs during the execution of the respective activity. If both sequence flows 
	-- (normal and non-interrupting) should be merged by a gateway, an inclusive 
	-- gateway would be required.
			pathMergedByAnInclusiveGateway()
		
	inv interruptingEventPathMergedByAnExclusiveGateway: 
	-- An attached interrupting event simply creates an token if it 
	-- occurs during the execution of the respective activity. If both sequence flows 
	-- (normal and interrupting) should be merged by a gateway, an exclusive 
	-- gateway would be required.
			pathMergedByAnExclusiveGateway()
		
		inv transactionCanOnlyHaveCancelEvent:
	-- Instead a normal intermediate event, a catching cancel intermediate event
	-- must be used  attached to the boundary of a transaction.
	isAttachedActivityTransaction() implies self.isCancelEvent()

		inv allowedEventType:
		-- Only some types of Start, Intermediate and End Events are allowed 
			((self.cancelActivity = true ) implies
			(not (self.isNoneEvent() or
						self.isLinkEvent() or
						self.isTerminateEvent())))
			or
			((self.cancelActivity = false ) implies
			(not (self.isCancelEvent() or
						self.isNoneEvent() or
						self.isLinkEvent() or
						self.isTerminateEvent() or
						self.isErrorEvent() or
						self.isCompensateEvent())))


		inv oneOutgoingSequenceFlow :
	-- A Boundary Event must have exactly one outgoing Sequence Flow (unless it 
	-- has the Compensation type).
	not self.isCompensateEvent() 
	implies 
	self.outgoing_a->size() = 1

		inv noIncomingSequenceFlow :
	-- A Boundary Event must not have incoming Sequence Flow 
	self.incoming_a->size() = 0

-------------------------------------------------------------------------------------	
context IntermediateCatchEvent
-------------------------------------------------------------------------------------	
		inv allowedEventType:
		-- Only some types of Start, Intermediate and End Events are allowed 
			(not (self.isNoneEvent() or
						self.isErrorEvent() or
						self.isEscalationEvent() or
						self.isCancelEvent() or
						self.isTerminateEvent() or
						self.isCompensateEvent()))

	 inv bp_shouldHaveName:
		-- An Event must have a name
		-- TO DO
	hasName()


  inv bp_incomingMessageFlow:
		-- A Catching Intermediate Message Event should have an incoming Message flow
		-- TO DO
	    hasMessageFlow()
	    
-------------------------------------------------------------------------------------	
context IntermediateThrowEvent
-------------------------------------------------------------------------------------	
		inv allowedEventType:
		-- Only some types of Start, Intermediate and End Events are allowed 
			(not (self.isCancelEvent() or
						self.isTimerEvent() or
						self.isErrorEvent() or
						self.isTerminateEvent() or
						self.isParallelMultipleEvent() or
						self.isConditionalEvent()))


		inv mandatorySequenceFlowTypedEvents:
		-- When Start and End Events are used, a  Intermediate Throw Event must have:
		-- must have exactly one incoming Sequence Flow if it is of type None,  Compensation,
		-- Message, Timer, Conditional, Link or Signal
		self.container.hasExplicitStartAndEndEvents() and 
		(self.isNoneEvent() or self.isCompensateEvent() or self.isMessageEvent() or self.isTimerEvent()
		 or self.isConditionalEvent() or self.isLinkEvent() or self.isSignalEvent()) 
		implies
		self.incoming_a->size() = 1

		inv mandatorySequence:
		-- When Start and End Events are used, a  Intermediate Throw Event must have:
		-- at least one incoming Sequence Flow in the other situations;
		self.container.hasExplicitStartAndEndEvents() 
		implies
		self.incoming_a->size() > 0

	 inv bp_shouldHaveName:
		-- An Event must have a name
		-- TO DO
	hasName()


  inv bp_outgoingMessageFlow:
  	-- A Throwing Intermediate Message Event should have an outgoing Message flow
		-- TO DO
	    hasMessageFlow()


-------------------------------------------------------------------------------------	
	context EndEvent
--------------------------------------------------------------------------------------
--		inv endEventCannotHaveOutputSequenceFlow: 
--	-- An end event cannot have an output sequence flow
--	withoutOutputSequenceFlows()

		inv allowedEventType:
		-- 4.5.1	Only some types of Start, Intermediate and End Events are allowed 
			not (self.isTimerEvent() or
						self.isConditionalEvent() or
						self.isLinkEvent() or
						self.isParallelMultipleEvent())

-------------------------------------------------------------------------------------	
	context Process
--------------------------------------------------------------------------------------
	inv noMoreThanOneUntypedStartEventInProcess:
	-- Models with more than one start events may lead to misinterpretations.
	-- When using multiple start event modeling, the use of several start 
	-- events is avoided. 
	-- If a process has several start events, not more than one of them should 
	-- be an untyped event. If there are several of them, it is not clear, at 
	-- which of these untyped start events the process should commence.
	-- If a process has several start events, not more than one of them should be 
	-- an untyped event
	
	totalNumberContainerStartEvents() - totalNumberContainerNoneStartEvents() <= 1
	
	-- A simplified external view of a process is called "public process".  
	-- An internal process with all its details is called "private process".
	-- According to the BPMN 2.0 specification, an extended process "supports" a 
	-- simple process, if the entire process logic of the simple process is 
	-- completely contained in the extended process.
	--  A public process can be created out of a private process, or vice versa. 
	-- (A public process is the combination of several elements into aggregated 
	-- activities of a private process, as well as the removal of elements not required.
	-- It is required that the external behavior concerning the message exchange 
	-- of both views must be the same.)
	
	
	
		inv catchingSignalEventHasThrowEventWithSameName: 
	-- Linking two processes with signal events events is not the best solution, since
	-- it is broadcasted to all processes and what is intended is start only one process. 
	-- The signal start event is triggered by the reception of a signal. 
	-- The catching signal for starting a process must have the same name (or be unnamed) as
	-- the throwing signal, which may be originate from the same pool, or from 
	-- a different pool and another process. 
		nameOfCatchingSignalEventMatchNameOfThrowingEvent()
--		self.isSignalEvent() implies
--			self.container.oclAsType(Process).definitionalCollaborationRef.process_a.totalContainerThrowEvents()
--			->one((name.isDefined() and self.name = name) or name.isUndefined() )

	inv publicProcessIsNotExecutable:
	-- A public Process shows only the flow elements that are relevant to
	-- external consumers. Internal details are not modeled (page 147),
	-- so there is not enough detail for the process to be executed. 
	 (self.processType = ProcessType::Public) implies   (self.isExecutable  <> true)
	
	
	  inv bp_activitiesNameMustBeUnique:
	-- Activities in the same Process should not have the same name
  -- TO DO
    isActivityNameUnique()

-------------------------------------------------------------------------------------
	context Transaction
--------------------------------------------------------------------------------------
	
	inv multiPathsRequireTerminateEndEvent:
	-- We must use at least one terminate end event to finish an entire sub-process 
	-- transaction, if there are several paths with typed or untyped end events.
	(totalNumberContainerEndEvents() > 1)
	implies
	(totalContainerEndEvents()->select(isTerminateEvent())->size() > 0)
	
	inv trowingCompensatingEventsNotAllowed:
	-- Throwing compensation end or intermediate events can be used when 
	-- compensations are modeled outside a transaction.
	totalContainerThrowEvents()->select(isCompensateEvent())->size() = 0
-------------------------------------------------------------------------------------	
	context SequenceFlow
--------------------------------------------------------------------------------------
	inv mustNotCrossBordersOfPools:
	-- Sequence flows are used for modeling the flow of an independent process 
	-- within one pool. Therefore, sequence flows must not cross borders of pools
	self.targetPool() = self.sourcePool()
	
	inv sourceMustNotBeEvent:
	-- A condition Expression must not be used if the Source of the Sequence Flow 
	-- is an Event
		self.sourceRef.oclIsKindOf(Event) implies conditionExpression.isUndefined()
	
	inv sourceMustNotBeEventBasedGateway:
	-- A condition Expression must not be used if the Source of the Sequence Flow 
	-- is an EventBasedGateway
		self.sourceRef.oclIsKindOf(EventBasedGateway) 
		implies 
		conditionExpression.isUndefined()
	
		inv sourceMustBeExclusiveInclusiveGateway:
	-- A condition Expression must be defined if the Source of the Sequence 
	-- Flow is an Inclusive Gateway 
	-- or Exclusive  Gateway (for know we disregard this last constraint)
	--	self.sourceRef.oclIsKindOf(ExclusiveGateway) or
			  self.sourceRef.oclIsKindOf(InclusiveGateway) 
		implies 
		conditionExpression.isDefined()
	
		inv sourceMustNotBeParalellComplexGateway:
	-- A condition Expression must not be used if the Source of the Sequence Flow 
	-- is a Paralell or Complex Gateway
		self.sourceRef.oclIsKindOf(ParallelGateway) or 
		self.sourceRef.oclIsKindOf(ComplexGateway) 
		implies 
		conditionExpression.isUndefined()
	

		inv conditionalCannotBeUsedIfOnlyOne:
	-- A conditional Sequence Flow cannot be used if there is only one sequence 
	-- flow out of the element
		(self.sourceRef.outgoing_a->size() = 1) implies conditionExpression.isUndefined()
	
	
	inv cannotCrossContainerBoundaries:
	-- Sequence Flows cannot cross container boundaries.
	self.sourceRef.container = self.targetRef.container
	
  inv sourceCannotBeTarget:
	-- Sequence Flows source and target must not be the same
	self.sourceRef <> self.targetRef

	
	-- Best-Practice
	-- Non-exclusive paths usually need to be joined by gateways
-------------------------------------------------------------------------------------	
	context MessageFlow
--------------------------------------------------------------------------------------
	-- the target of a message flow must be a catch message event or a receive task
	-- the source of a message flow must be a trow message event or a send task
	
	inv mustCrossBordersOfPools:
	-- message flows are only allowed between different pools, but not within one pool,
	-- because start and end of a message flow must be in different pools.
	self.targetPool()->asOrderedSet()->first().isDefined() and 
	self.sourcePool()->asOrderedSet()->first().isDefined()
	implies
	self.targetPool() <> self.sourcePool()

	inv allowedSource:
	-- A Message Flow can only have as source Message End or Intermediate Throw 
	-- Event; Send, User, or Service Task; Subprocess; or black box pool.
	(self.sourceRef.oclIsTypeOf(EndEvent) 
	implies
	self.sourceRef.oclAsType(ThrowEvent).isMessageEvent()) or
	(self.sourceRef.oclIsTypeOf(IntermediateThrowEvent) 
	implies
	self.sourceRef.oclAsType(ThrowEvent).isMessageEvent()) or
	self.sourceRef.oclIsTypeOf(SendTask) or
	self.sourceRef.oclIsTypeOf(UserTask) or
	self.sourceRef.oclIsTypeOf(ServiceTask) or
	self.sourceRef.oclIsTypeOf(SubProcess) or
	self.sourcePool()->asOrderedSet()->first().isBlackBox()

	inv allowedTarget:
	-- A Message Flow can only go to a Message Start or Intermediate Catch Event, 
	-- Boundary Event; Receive, User, or Service Task; Subprocess; or black box pool
	(self.targetRef.oclIsTypeOf(StartEvent) 
	implies
	self.targetRef.oclAsType(CatchEvent).isMessageEvent()) or
	(self.targetRef.oclIsTypeOf(IntermediateCatchEvent) 
	implies
	self.targetRef.oclAsType(CatchEvent).isMessageEvent()) or
	(self.targetRef.oclIsTypeOf(BoundaryEvent) 
	implies
	self.targetRef.oclAsType(CatchEvent).isMessageEvent()) or
	self.targetRef.oclIsTypeOf(SendTask) or
	self.targetRef.oclIsTypeOf(UserTask) or
	self.targetRef.oclIsTypeOf(ServiceTask) or
	self.targetRef.oclIsTypeOf(SubProcess) or
	self.targetPool()->asOrderedSet()->first().isBlackBox()

	inv doNotConnectToWhiteBox:
	-- A Message Flow should not connect to the border of a "white Box" Pool
	(self.targetRef.oclIsTypeOf(Participant) implies
	not self.targetRef.oclAsType(Participant).isWhiteBox())
	and
	(self.sourceRef.oclIsTypeOf(Participant) implies
	not self.sourceRef.oclAsType(Participant).isWhiteBox())

  inv bp_hasMessageName:
	-- A Message Flow should be named with the name of the Message
  -- TO DO
    hasMessageName()




-------------------------------------------------------------------------------------	
	context Message
--------------------------------------------------------------------------------------

	inv allowedConnectors:
	-- A Message must be attached to a Message Flow or must be connected to 
	-- an Association connecting to a Message Flow, a Send Task or a Receive Task, 
	-- or a Message Event Definition
	self.messageFlow->size() > 0 or 
	self.sendTask->size() > 0 or 
	self.receiveTask->size() > 0 or 
	self.messageEventDefinition->size() > 0 
	 

-------------------------------------------------------------------------------------	
--	context DataAssociation
--------------------------------------------------------------------------------------
	-- Data objects only exist within a process; therefore data associations cannot 
	-- cross the borders of pools.
	
	
-------------------------------------------------------------------------------------	
	context Association
--------------------------------------------------------------------------------------
	
	inv connectedToTextAnnotation:
	-- An Association that is connected to a Text Annotation should have a None Direction
	(self.targetRef.oclIsTypeOf(TextAnnotation) or
	self.sourceRef.oclIsTypeOf(TextAnnotation)) 
	implies
	self.associationDirection = AssociationDirection::None
	
	inv connectTwoTextAnnotation:
	-- An Association should not connect two Text Annotations
	not (self.targetRef.oclIsTypeOf(TextAnnotation) and
	self.sourceRef.oclIsTypeOf(TextAnnotation))
	
	
	-------------------------------------------------------------------------------------	
	context TextAnnotation
--------------------------------------------------------------------------------------
	inv connectToAssociation:
	-- An Association must connect to a Text Annotation 
	(self.incoming->notEmpty() or
	self.outgoing->notEmpty())


